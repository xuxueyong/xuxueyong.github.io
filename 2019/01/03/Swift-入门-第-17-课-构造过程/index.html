<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Swift 入门 第 17 课-构造过程 | 云山之处</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="像写诗一样, 将写代码作为一门艺术.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Swift 入门 第 17 课-构造过程 | 云山之处">
    <meta name="twitter:description" content="像写诗一样, 将写代码作为一门艺术.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Swift 入门 第 17 课-构造过程 | 云山之处">
    <meta property="og:description" content="像写诗一样, 将写代码作为一门艺术.">

    
    <meta name="author" content="徐雪勇">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="云山之处" href="/atom.xml">
    

    <link rel="canonical" href="http://xuxueyong.github.io/2019/01/03/Swift-入门-第-17-课-构造过程/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 云山之处 的主页"><img src="/images/avatar.jpg" width="80" alt="云山之处 logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 云山之处">云山之处</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">最好的时代, 活出最好的自己</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">像写诗一样, 将写代码作为一门艺术.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="https://www.jianshu.com/u/823519e76f1a">简书</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
              <li class="navigation__item"><a href="/favourite/image.html">幻想间</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/u/2506861343?is_all=1" title="Weibo" target="_blank">
      <i class="social fa fa-weibo"></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/xuxueyong" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-blue"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-01-03T02:37:34.658Z" class="post-list__meta--date date">2019-01-03</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Swift 入门 第 17 课-构造过程</h1>
  </header>

  <section class="post">
    <p>构造过程是使用类和结构体或枚举之类的实例前， 必须的准备过程。与 Object-C 不同， Swift 的初始化没有返回值。</p>
<p>析构器可以在实例释放之前执行一些清除工作。</p>
<h4 id="存储属性的初始赋值"><a href="#存储属性的初始赋值" class="headerlink" title="存储属性的初始赋值"></a>存储属性的初始赋值</h4><p>存储属性在实例化之后， 必须指定值。存储属性的值， 不能处于未知状态。要么在初始化的时候被赋值，要么声明的时候指定默认值。</p>
<blockquote>
<p>注意：<br>当存储属性在初始化和被指定默认值时，是不会触发属性观察者的。</p>
</blockquote>
<h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><p>创建某个特定的类型实例时， 被调用， 类似于实例方法， 不带任何参数， 用 <code>init</code>开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init() &#123;</span><br><span class="line">    // 在此处执行构造过程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面例子中定义了一个用来保存华氏温度的结构体 Fahrenheit，它拥有一个 Double 类型的存储型属性 temperature：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Fahrenheit &#123;</span><br><span class="line">    var temperature: Double</span><br><span class="line">    init() &#123;</span><br><span class="line">        temperature = 32.0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = Fahrenheit()</span><br><span class="line">print(&quot;The default temperature is \(f.temperature)° Fahrenheit&quot;)</span><br><span class="line">// 打印 &quot;The default temperature is 32.0° Fahrenheit&quot;</span><br></pre></td></tr></table></figure>
<p>这个结构体定义了一个不带参数的构造器 init，并在里面将存储型属性 temperature 的值初始化为 32.0（华氏温度下水的冰点）。</p>
<h4 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h4><p>如前所述，你可以在构造器中为存储型属性设置初始值。同样，你也可以在属性声明时为其设置默认值。</p>
<blockquote>
<p>注意：<br>指定默认值， 比初始化的时候指定的值一样要好， 有继承的时候， 可以让子类在默认构造器中使用不同的初始值进行初始化更方便。</p>
</blockquote>
<p>使用默认值, 默认初始化方法可以不用写出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct Fahrenheit &#123;</span><br><span class="line">    var temperature = 32.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义构造过程"><a href="#自定义构造过程" class="headerlink" title="自定义构造过程"></a>自定义构造过程</h4><p>你可以通过输入参数和可选类型的属性来自定义构造过程，也可以在构造过程中给常量属性赋初值。这些都将在后面章节中提到。</p>
<h4 id="构造参数"><a href="#构造参数" class="headerlink" title="构造参数"></a>构造参数</h4><p>构造参数的语法与函数和方法的参数一样。<br>下面是一个用两种不同温度标准表示的温度值， 统一转化为摄氏温度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct Celsius &#123;</span><br><span class="line">    var temperatureInCelsius: Double</span><br><span class="line">    init(fromFahrenheit fahrenheit: Double) &#123;</span><br><span class="line">        temperatureInCelsius = (fahrenheit - 32.0) / 1.8</span><br><span class="line">    &#125;</span><br><span class="line">    init(fromKelvin kelvin: Double) &#123;</span><br><span class="line">        temperatureInCelsius = kelvin - 273.15</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)</span><br><span class="line">// boilingPointOfWater.temperatureInCelsius 是 100.0</span><br><span class="line">let freezingPointOfWater = Celsius(fromKelvin: 273.15)</span><br><span class="line">// freezingPointOfWater.temperatureInCelsius 是 0.0</span><br></pre></td></tr></table></figure>
<p>第一个构造器的外部参数名为 fromFahrenheit， 内部参数名为 fahrenheit。</p>
<h4 id="不带参数标签的构造器参数"><a href="#不带参数标签的构造器参数" class="headerlink" title="不带参数标签的构造器参数"></a>不带参数标签的构造器参数</h4><p>和函数和方法语法一样， 使用 <code>_</code> 语法来忽略掉外部参数名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Celsius &#123;</span><br><span class="line">    var temperatureInCelsius: Double</span><br><span class="line">    init(_ celsius: Double)&#123;</span><br><span class="line">        temperatureInCelsius = celsius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let bodyTemperature = Celsius(37.0)</span><br><span class="line">// bodyTemperature.temperatureInCelsius 为 37.0</span><br></pre></td></tr></table></figure>
<h4 id="可选属性类型"><a href="#可选属性类型" class="headerlink" title="可选属性类型"></a>可选属性类型</h4><p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性——无论是因为它无法在初始化时赋值，还是因为它在之后某个时间点可以赋值为空——你都需要将它定义为 可选类型。可选类型的属性将自动初始化为 nil，表示这个属性是有意在初始化时设置为空的。</p>
<p>下面例子中定义了类 SurveyQuestion，它包含一个可选字符串属性 response：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class SurveyQuestion &#123;</span><br><span class="line">    var text: String</span><br><span class="line">    var response: String?</span><br><span class="line">    init(text: String) &#123;</span><br><span class="line">        self.text = text</span><br><span class="line">    &#125;</span><br><span class="line">    func ask() &#123;</span><br><span class="line">        print(text)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cheeseQuestion = SurveyQuestion(text: &quot;Do you like cheese?&quot;)</span><br><span class="line">cheeseQuestion.ask()</span><br><span class="line">// 打印 &quot;Do you like cheese?&quot;</span><br><span class="line">cheeseQuestion.response = &quot;Yes, I do like cheese.&quot;</span><br></pre></td></tr></table></figure>
<p>调查问题的答案在回答前是无法确定的，因此我们将属性 response 声明为 String? 类型，或者说是 可选字符串类型。当 SurveyQuestion 实例化时，它将自动赋值为 nil，表明此字符串暂时还没有值。</p>
<h4 id="构造过程中常量属性的赋值"><a href="#构造过程中常量属性的赋值" class="headerlink" title="构造过程中常量属性的赋值"></a>构造过程中常量属性的赋值</h4><p>常量属性的值，只能构造过程结束前被指定值。一旦被赋值， 以后不能再被更改。即使在子类中， 也不能修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SurveyQuestion &#123;</span><br><span class="line">    let text: String</span><br><span class="line">    init(text: String) &#123;</span><br><span class="line">        self.text = text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>text 是常量， 我们可以在构造器中修改它的值。</p>
<h4 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h4><p>结构体和类的每一个存储属性都有默认值时， 不自定义构造器， 将会有默认构造器初始化实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class ShoppingListItem &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    var quantity = 1</span><br><span class="line">    var purchased = false</span><br><span class="line">&#125;</span><br><span class="line">var item = ShoppingListItem()</span><br></pre></td></tr></table></figure>
<p>上面例子中使用默认构造器创造了一个 ShoppingListItem 类的实例（使用 ShoppingListItem() 形式的构造器语法），并将其赋值给变量 item。</p>
<h4 id="结构体的逐一成员构造器"><a href="#结构体的逐一成员构造器" class="headerlink" title="结构体的逐一成员构造器"></a>结构体的逐一成员构造器</h4><p>除了上面提到的默认构造器，如果结构体没有提供自定义的构造器，它们将自动获得一个逐一成员构造器（memberwise initializer），即使结构体的存储型属性没有默认值。</p>
<p>结构体 Size 自动获得了一个逐一成员构造器 init(width:height:)。你可以用它来创建新的 Size 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line">let twoByTwo = Size(width: 2.0, height: 2.0)</span><br></pre></td></tr></table></figure>
<h4 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h4><p>构造器可以调用其他构造器来完成实例部分的构造过程。这一过程称为构造代理。</p>
<p>值类型的构造代理和引用类型不一样， 值类型的构造代理只能调用自己的其他构造器方法。 而引用类型的构造器可以调用父类的构造器。</p>
<p>如果为结构体定义了构造器， 将不能访问默认构造器和逐一成员构造器。</p>
<blockquote>
<p>注意：<br>如果想在结构体定义了构造器之后， 还想使用默认构造器和逐一成员构造器， 可以显示再次定义这些构造器。 一般写在扩展中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct Size &#123;</span><br><span class="line">    var width = 0.0, height = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Rect &#123;</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    init() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    init(origin: Point, size: Size) &#123;</span><br><span class="line">        self.origin = origin</span><br><span class="line">        self.size = size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init(center: Point, size: Size) &#123;</span><br><span class="line">        let originX = center.x - (size.width / 2)</span><br><span class="line">        let originY = center.y - (size.height / 2)</span><br><span class="line">        self.init(origin: Point(x: originX, y: originY), size: size)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init()  可以有默认值实现初始化。  init(origin: Point, size: Size) 相当于逐一成员构造器<br>init(center: Point, size: Size) 使用了其他构造器。</p>
<h4 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h4><p>类里面的所有存储型属性——包括所有继承自父类的属性——都必须在构造过程中设置初始值。 <a href=""></a> Swift 为类类型提供了两种构造器来确保实例中所有存储型属性都能获得初始值，它们分别是指定构造器和便利构造器。</p>
<h4 id="指定构造器和便利构造器"><a href="#指定构造器和便利构造器" class="headerlink" title="指定构造器和便利构造器"></a>指定构造器和便利构造器</h4><p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类合适的构造器来实现父类的初始化。</p>
<p>类倾向于拥有少量指定构造器，普遍的是一个类拥有一个指定构造器。指定构造器在初始化的地方通过“管道”将初始化过程持续到父类链。</p>
<p>每一个类都必须至少拥有一个指定构造器。在某些情况下，许多类通过继承了父类中的指定构造器而满足了这个条件。具体内容请参考后续章节构造器的自动继承。</p>
<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入值的实例。</p>
<p>你应当只在必要的时候为类提供便利构造器，比方说某种情况下通过使用便利构造器来快捷调用某个指定构造器，能够节省更多开发时间并让类的构造过程更清晰明了。</p>
<h4 id="指定构造器和便利构造器的语法"><a href="#指定构造器和便利构造器的语法" class="headerlink" title="指定构造器和便利构造器的语法"></a>指定构造器和便利构造器的语法</h4><p>类的指定构造器的写法跟值类型简单构造器一样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>便利构造器也采用相同样式的写法，但需要在 init 关键字之前放置 convenience 关键字，并使用空格将它们俩分开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">convenience init(parameters) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的构造器代理规则"><a href="#类的构造器代理规则" class="headerlink" title="类的构造器代理规则"></a>类的构造器代理规则</h4><p>规则 1</p>
<pre><code>指定构造器必须调用其直接父类的的指定构造器。
</code></pre><p>规则 2</p>
<pre><code>便利构造器必须调用同类中定义的其它构造器。
</code></pre><p>规则 3</p>
<pre><code>便利构造器最后必须调用指定构造器。
</code></pre><p>一个更方便记忆的方法是：</p>
<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>
<h4 id="两段式构造过程"><a href="#两段式构造过程" class="headerlink" title="两段式构造过程"></a>两段式构造过程</h4><p>Swift 中类的构造过程包含两个阶段。第一个阶段，类中的每个存储型属性赋一个初始值。当每个存储型属性的初始值被赋值后，第二阶段开始，它给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性。</p>
<p>两段式构造过程的使用让构造过程更安全，同时在整个类层级结构中给予了每个类完全的灵活性。两段式构造过程可以防止属性值在初始化之前被访问，也可以防止属性被另外一个构造器意外地赋予不同的值。</p>
<blockquote>
<p>注意：<br>Swift 的两段式构造过程跟 Objective-C 中的构造过程类似。最主要的区别在于阶段 1，Objective-C 给每一个属性赋值 0 或空值（比如说 0 或 nil）。Swift 的构造流程则更加灵活，它允许你设置定制的初始值，并自如应对某些属性不能以 0 或 nil 作为合法默认值的情况。</p>
</blockquote>
<p>Swift 编译器将执行 4 种有效的安全检查，以确保两段式构造过程不出错地完成：</p>
<p><strong>安全检查 1</strong></p>
<pre><code>指定构造器必须保证它所在类的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。
</code></pre><p>如上所述，一个对象的内存只有在其所有存储型属性确定之后才能完全初始化。为了满足这一规则，指定构造器必须保证它所在类的属性在它往上代理之前先完成初始化。</p>
<p><strong>安全检查 2</strong></p>
<pre><code>指定构造器必须在为继承的属性设置新值之前向上代理调用父类构造器，如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。
</code></pre><p><strong>安全检查 3</strong></p>
<pre><code>便利构造器必须为任意属性（包括同类中定义的）赋新值之前代理调用同一类中的其它构造器，如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。
</code></pre><p><strong>安全检查 4</strong></p>
<pre><code>构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。
</code></pre><p>阶段 1</p>
<ul>
<li>某个指定构造器或便利构造器被调用。</li>
<li>完成新实例内存的分配，但此时内存还没有被初始化。</li>
<li>指定构造器确保其所在类引入的所有存储型属性都已赋初值。存储型属性所属的内存完成初始化。</li>
<li>指定构造器将调用父类的构造器，完成父类属性的初始化。</li>
<li>这个调用父类构造器的过程沿着构造器链一直往上执行，直到到达构造器链的最顶部。</li>
<li>当到达了构造器链最顶部，且已确保所有实例包含的存储型属性都已经赋值，这个实例的内存被认为已经完全初始化。此时阶段 1 完成。</li>
</ul>
<p>阶段 2</p>
<ul>
<li>从顶部构造器链一直往下，每个构造器链中类的指定构造器都有机会进一步定制实例。构造器此时可以访问self、修改它的属性并调用实例方法等等。</li>
<li>最终，任意构造器链中的便利构造器可以有机会定制实例和使用 self。</li>
</ul>
<h4 id="构造器的继承和重写"><a href="#构造器的继承和重写" class="headerlink" title="构造器的继承和重写"></a>构造器的继承和重写</h4><p>Swift 和 Object-C 不一样， 不会默认的集成父类的构造器。</p>
<p>当你在编写一个和父类中指定构造器相匹配的子类构造器时，你实际上是在重写父类的这个指定构造器。因此，你必须在定义子类构造器时带上 override 修饰符。即使你重写的是系统自动提供的默认构造器，也需要带上 override 修饰符，具体内容请参考默认构造器。</p>
<p>正如重写属性，方法或者是下标，override 修饰符会让编译器去检查父类中是否有相匹配的指定构造器，并验证构造器参数是否正确。</p>
<p>相反，如果你编写了一个和父类便利构造器相匹配的子类构造器，由于子类不能直接调用父类的便利构造器（每个规则都在上文类的构造器代理规则有所描述），因此，严格意义上来讲，你的子类并未对一个父类构造器提供重写。最后的结果就是，你在子类中“重写”一个父类便利构造器时，不需要加 override 修饰符。（这里的重写， 不是真正的重写， 而是重新定义了一个名字和父类一样的便利构造器）。</p>
<h4 id="构造器的自动继承"><a href="#构造器的自动继承" class="headerlink" title="构造器的自动继承"></a>构造器的自动继承</h4><p>如上所述，子类在默认情况下不会继承父类的构造器。但是如果满足特定条件，父类构造器是可以被自动继承的。事实上，这意味着对于许多常见场景你不必重写父类的构造器，并且可以在安全的情况下以最小的代价继承父类的构造器。</p>
<p>假设你为子类中引入的所有新属性都提供了默认值，以下 2 个规则适用：</p>
<p><strong>规则 1</strong></p>
<pre><code>如果子类没有定义任何指定构造器，它将自动继承父类所有的指定构造器。
</code></pre><p><strong>规则 2</strong></p>
<pre><code>如果子类提供了所有父类指定构造器的实现——无论是通过规则 1 继承过来的，还是提供了自定义实现——它将自动继承父类所有的便利构造器。
</code></pre><p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。</p>
<blockquote>
<p>注意：<br>对于规则 2，子类可以将父类的指定构造器实现为便利构造器。</p>
</blockquote>
<h4 id="指定构造器和便利构造器实践"><a href="#指定构造器和便利构造器实践" class="headerlink" title="指定构造器和便利构造器实践"></a>指定构造器和便利构造器实践</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Food &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    convenience init() &#123;</span><br><span class="line">        self.init(name: &quot;[Unnamed]&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类类型没有默认的逐一成员构造器，所以 Food 类提供了一个接受单一参数 name 的指定构造器。这个构造器可以使用一个特定的名字来创建新的 Food 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let namedMeat = Food(name: &quot;Bacon&quot;)</span><br><span class="line">// namedMeat 的名字是 &quot;Bacon&quot;</span><br></pre></td></tr></table></figure>
<p>Food 类中的构造器 init(name: String) 被定义为一个指定构造器，因为它能确保 Food 实例的所有存储型属性都被初始化。Food 类没有父类，所以 init(name: String) 构造器不需要调用 super.init() 来完成构造过程。</p>
<p>Food 类同样提供了一个没有参数的便利构造器 init()。这个 init() 构造器为新食物提供了一个默认的占位名字，通过横向代理到指定构造器 init(name: String) 并给参数 name 赋值为 [Unnamed] 来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mysteryMeat = Food()</span><br><span class="line">// mysteryMeat 的名字是 [Unnamed]</span><br></pre></td></tr></table></figure>
<p>类层级中的第二个类是 Food 的子类 RecipeIngredient。RecipeIngredient 类用来表示食谱中的一项原料。它引入了 Int 类型的属性 quantity（以及从 Food 继承过来的 name 属性），并且定义了两个构造器来创建 RecipeIngredient 实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class RecipeIngredient: Food &#123;</span><br><span class="line">    var quantity: Int</span><br><span class="line">    init(name: String, quantity: Int) &#123;</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    override convenience init(name: String) &#123;</span><br><span class="line">        self.init(name: name, quantity: 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 子类可以调用父类的便利构造器。 调用链 convenience init() ---&gt; override convenience init(name: String) ---&gt; init(name: String, quantity: Int) --&gt; init(name: String)</span><br><span class="line">let oneMysteryItem = RecipeIngredient() </span><br><span class="line"></span><br><span class="line">// 将父类的指定构造器重写为 便利构造器， 完成初始化。</span><br><span class="line">let oneBacon = RecipeIngredient(name: &quot;Bacon&quot;)</span><br><span class="line"></span><br><span class="line">// 子类的自定义指定构造器， 里面调用了父类的指定构造器。</span><br><span class="line">let sixEggs = RecipeIngredient(name: &quot;Eggs&quot;, quantity: 6)</span><br></pre></td></tr></table></figure>
<h4 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h4><p>如果一个类、结构体或枚举类型的对象，在构造过程中有可能失败，则为其定义一个可失败构造器是很有用的。这里所指的“失败” 指的是，如给构造器传入无效的参数值，或缺少某种所需的外部资源，又或是不满足某种必要的条件等。</p>
<p>为了妥善处理这种构造过程中可能会失败的情况。你可以在一个类，结构体或是枚举类型的定义中，添加一个或多个可失败构造器。其语法为在 init 关键字后面添加问号（init?）。</p>
<blockquote>
<p>注意：<br>可失败构造器的参数名和参数类型，不能与其它非可失败构造器的参数名，及其参数类型相同。</p>
</blockquote>
<p>可失败构造器会创建一个类型为自身类型的可选类型的对象。你通过 return nil 语句来表明可失败构造器在何种情况下应该 “失败”。</p>
<blockquote>
<p>注意：<br>严格来说，构造器都不支持返回值。因为构造器本身的作用，只是为了确保对象能被正确构造。因此你只是用 return nil 表明可失败构造器构造失败，而不要用关键字 return 来表明构造成功。</p>
</blockquote>
<p>例如，实现针对数字类型转换的可失败构造器。确保数字类型之间的转换能保持精确的值，使用这个 init(exactly:) 构造器。如果类型转换不能保持值不变，则这个构造器构造失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let wholeNumber: Double = 12345.0</span><br><span class="line">let pi = 3.14159</span><br><span class="line"></span><br><span class="line">if let valueMaintained = Int(exactly: wholeNumber) &#123;</span><br><span class="line">    print(&quot;\(wholeNumber) conversion to Int maintains value of \(valueMaintained)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;12345.0 conversion to Int maintains value of 12345&quot;</span><br><span class="line"></span><br><span class="line">let valueChanged = Int(exactly: pi)</span><br><span class="line">// valueChanged 是 Int? 类型，不是 Int 类型</span><br><span class="line"></span><br><span class="line">if valueChanged == nil &#123;</span><br><span class="line">    print(&quot;\(pi) conversion to Int does not maintain value&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;3.14159 conversion to Int does not maintain value&quot;</span><br></pre></td></tr></table></figure>
<p>下例中，定义了一个名为 Animal 的结构体，其中有一个名为 species 的 String 类型的常量属性。同时该结构体还定义了一个接受一个名为 species 的 String 类型参数的可失败构造器。这个可失败构造器检查传入的参数是否为一个空字符串。如果为空字符串，则构造失败。否则，species 属性被赋值，构造成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Animal &#123;</span><br><span class="line">    let species: String</span><br><span class="line">    init?(species: String) &#123;</span><br><span class="line">        if species.isEmpty &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        self.species = species</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="枚举类型的可失败构造器"><a href="#枚举类型的可失败构造器" class="headerlink" title="枚举类型的可失败构造器"></a>枚举类型的可失败构造器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureUnit &#123;</span><br><span class="line">    case Kelvin, Celsius, Fahrenheit</span><br><span class="line">    init?(symbol: Character) &#123;</span><br><span class="line">        switch symbol &#123;</span><br><span class="line">        case &quot;K&quot;:</span><br><span class="line">            self = .Kelvin</span><br><span class="line">        case &quot;C&quot;:</span><br><span class="line">            self = .Celsius</span><br><span class="line">        case &quot;F&quot;:</span><br><span class="line">            self = .Fahrenheit</span><br><span class="line">        default:</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以利用该可失败构造器在三个枚举成员中获取一个相匹配的枚举成员，当参数的值不能与任何枚举成员相匹配时，则构造失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let fahrenheitUnit = TemperatureUnit(symbol: &quot;F&quot;)</span><br><span class="line">if fahrenheitUnit != nil &#123;</span><br><span class="line">    print(&quot;This is a defined temperature unit, so initialization succeeded.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;This is a defined temperature unit, so initialization succeeded.&quot;</span><br><span class="line"></span><br><span class="line">let unknownUnit = TemperatureUnit(symbol: &quot;X&quot;)</span><br><span class="line">if unknownUnit == nil &#123;</span><br><span class="line">    print(&quot;This is not a defined temperature unit, so initialization failed.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;This is not a defined temperature unit, so initialization failed.&quot;</span><br></pre></td></tr></table></figure>
<h4 id="带原始值的枚举类型的可失败构造器"><a href="#带原始值的枚举类型的可失败构造器" class="headerlink" title="带原始值的枚举类型的可失败构造器"></a>带原始值的枚举类型的可失败构造器</h4><p>带原始值的枚举类型会自带一个可失败构造器 init?(rawValue:)，该可失败构造器有一个名为 rawValue 的参数，其类型和枚举类型的原始值类型一致，如果该参数的值能够和某个枚举成员的原始值匹配，则该构造器会构造相应的枚举成员，否则构造失败。</p>
<p>因此上面的 TemperatureUnit 的例子可以重写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureUnit: Character &#123;</span><br><span class="line">    case Kelvin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let fahrenheitUnit = TemperatureUnit(rawValue: &quot;F&quot;)</span><br><span class="line">if fahrenheitUnit != nil &#123;</span><br><span class="line">    print(&quot;This is a defined temperature unit, so initialization succeeded.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;This is a defined temperature unit, so initialization succeeded.&quot;</span><br><span class="line"></span><br><span class="line">let unknownUnit = TemperatureUnit(rawValue: &quot;X&quot;)</span><br><span class="line">if unknownUnit == nil &#123;</span><br><span class="line">    print(&quot;This is not a defined temperature unit, so initialization failed.&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;This is not a defined temperature unit, so initialization failed.&quot;</span><br></pre></td></tr></table></figure>
<h4 id="构造失败的传递"><a href="#构造失败的传递" class="headerlink" title="构造失败的传递"></a>构造失败的传递</h4><p>类，结构体，枚举的可失败构造器可以横向代理到同类型中的其他可失败构造器。类似的，子类的可失败构造器也能向上代理到父类的可失败构造器。</p>
<p>无论是向上代理还是横向代理，如果你代理到的其他可失败构造器触发构造失败，整个构造过程将立即终止，接下来的任何构造代码不会再被执行。</p>
<blockquote>
<p>注意：<br>可失败构造器也可以代理到其它的非可失败构造器。通过这种方式，你可以增加一个可能的失败状态到现有的构造过程中。</p>
</blockquote>
<p>下面这个例子，定义了一个名为 CartItem 的 Product 类的子类。这个类建立了一个在线购物车中的物品的模型，它有一个名为 quantity 的常量存储型属性，并确保该属性的值至少为 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">    let name: String</span><br><span class="line">    init?(name: String) &#123;</span><br><span class="line">        if name.isEmpty &#123; return nil &#125;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class CartItem: Product &#123;</span><br><span class="line">    let quantity: Int</span><br><span class="line">    init?(name: String, quantity: Int) &#123;</span><br><span class="line">        if quantity &lt; 1 &#123; return nil &#125;</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CartItem 可失败构造器首先验证接收的 quantity 值是否大于等于 1 。倘若 quantity 值无效，则立即终止整个构造过程，返回失败结果，且不再执行余下代码。同样地，Product 的可失败构造器首先检查 name 值，假如 name 值为空字符串，则构造器立即执行失败。</p>
<h4 id="重写一个可失败构造器"><a href="#重写一个可失败构造器" class="headerlink" title="重写一个可失败构造器"></a>重写一个可失败构造器</h4><p>如同其它的构造器，你可以在子类中重写父类的可失败构造器。或者你也可以用子类的非可失败构造器重写一个父类的可失败构造器。这使你可以定义一个不会构造失败的子类，即使父类的构造器允许构造失败。</p>
<p>注意，当你用子类的非可失败构造器重写父类的可失败构造器时，向上代理到父类的可失败构造器的唯一方式是对父类的可失败构造器的返回值进行强制解包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Document &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">    // 该构造器创建了一个 name 属性的值为 nil 的 document 实例</span><br><span class="line">    init() &#123;&#125;</span><br><span class="line">    // 该构造器创建了一个 name 属性的值为非空字符串的 document 实例</span><br><span class="line">    init?(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        if name.isEmpty &#123; return nil &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class UntitledDocument: Document &#123;</span><br><span class="line">    override init() &#123;</span><br><span class="line">        super.init(name: &quot;[Untitled]&quot;)!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h4><p>在类的构造器前添加 required 修饰符表明所有该类的子类都必须实现该构造器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">    required init() &#123;</span><br><span class="line">        // 构造器的实现代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在子类重写父类的必要构造器时，必须在子类的构造器前也添加 required 修饰符，表明该构造器要求也应用于继承链后面的子类。在重写父类中必要的指定构造器时，不需要添加 override 修饰符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SomeSubclass: SomeClass &#123;</span><br><span class="line">    required init() &#123;</span><br><span class="line">        // 构造器的实现代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通过闭包或函数设置属性的默认值"><a href="#通过闭包或函数设置属性的默认值" class="headerlink" title="通过闭包或函数设置属性的默认值"></a>通过闭包或函数设置属性的默认值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">    let someProperty: SomeType = &#123;</span><br><span class="line">        // 在这个闭包中给 someProperty 创建一个默认值</span><br><span class="line">        // someValue 必须和 SomeType 类型相同</span><br><span class="line">        return someValue</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意闭包结尾的花括号后面接了一对空的小括号。这用来告诉 Swift 立即执行此闭包。如果你忽略了这对括号，相当于将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>
<blockquote>
<p>注意：<br>如果你使用闭包来初始化属性，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能在闭包里访问其它属性，即使这些属性有默认值。同样，你也不能使用隐式的 self 属性，或者调用任何实例方法。</p>
</blockquote>
<p>【 参考 梁杰 极客学院 】</p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2019/01/03/Swift-入门-第-18-课-析构过程/" title="Swift 入门 第 18 课-析构过程">Swift 入门 第 18 课-析构过程</a></h2>
                <p class="excerpt">
                
                析构过程原理Swift 会自动释放不再需要的实例以释放资源。如自动引用计数章节中所讲述，Swift 通过自动引用计数（ARC) 处理实例的内存管理。通常当你的实例被释放时不需要手动地去清理。但是，当使用自己的资源时，你可能需要进行一些额外的清理。例如，如果创建了一个自定义的类来打开一个文件，并写入一
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-01-03T07:56:29.893Z" class="post-list__meta--date date">2019-01-03</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2019/01/03/Swift-入门-第-18-课-析构过程/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/12/29/Swift-入门-第-16-课-继承/" title="Swift 入门 第 16 课 继承">Swift 入门 第 16 课 继承</a></h2>
                <p class="excerpt">
                
                一个类可以继承其他类的属性、方法、特性等，继承的类叫子类， 被继承的类叫父类（或被称为超类）。
Swift 的类是区别其他类型的重要特征。子类可以重写父类的属性、方法、下标等。 Swift 会检查你重写是否在父类中有匹配的定义， 确保重写行为是正确的。
子类中可以给父类的存储属性和计算属性添加属性观
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-12-29T09:21:45.565Z" class="post-list__meta--date date">2018-12-29</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/12/29/Swift-入门-第-16-课-继承/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2019 徐雪勇 - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
