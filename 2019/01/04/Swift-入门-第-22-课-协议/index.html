<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Swift 入门 第 22 课 协议 | 云山之处</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="像写诗一样, 将写代码作为一门艺术.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Swift 入门 第 22 课 协议 | 云山之处">
    <meta name="twitter:description" content="像写诗一样, 将写代码作为一门艺术.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Swift 入门 第 22 课 协议 | 云山之处">
    <meta property="og:description" content="像写诗一样, 将写代码作为一门艺术.">

    
    <meta name="author" content="徐雪勇">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="云山之处" href="/atom.xml">
    

    <link rel="canonical" href="http://xuxueyong.github.io/2019/01/04/Swift-入门-第-22-课-协议/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 云山之处 的主页"><img src="/images/avatar.jpg" width="80" alt="云山之处 logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 云山之处">云山之处</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">最好的时代, 活出最好的自己</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">像写诗一样, 将写代码作为一门艺术.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="https://www.jianshu.com/u/823519e76f1a">简书</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
              <li class="navigation__item"><a href="/favourite/image.html">幻想间</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/u/2506861343?is_all=1" title="Weibo" target="_blank">
      <i class="social fa fa-weibo"></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/xuxueyong" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-blue"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2019-01-04T03:52:17.515Z" class="post-list__meta--date date">2019-01-04</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Swift 入门 第 22 课 协议</h1>
  </header>

  <section class="post">
    <p>协议只定义要做哪些内容， 就像画一个蓝图。遵循协议的类型， 具体实现协议中指定的方法，属性等。</p>
<h4 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h4><p>定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    // 这里是协议的定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在类型名称后加上协议名称，中间以冒号（:）分隔。遵循多个协议时，各协议之间用逗号（,）分隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct SomeStructure: FirstProtocol, AnotherProtocol &#123;</span><br><span class="line">    // 这里是结构体的定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拥有父类的类在遵循协议时，应该将父类名放在协议名之前，以逗号分隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass: SomeSuperClass, FirstProtocol, AnotherProtocol &#123;</span><br><span class="line">    // 这里是类的定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h4><p>协议不指定属性是存储属性还是计算型属性。协议要求属性是可读可写的， 就不能声明为常量或者可读的计算型属性。</p>
<p>协议使用 <code>var</code> 关键字加变量名称。 {set get} 表示可读可写， {get} 表示可读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    var mustBeSettable: Int &#123; get set &#125;</span><br><span class="line">    var doesNotNeedToBeSettable: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在协议中定义类型属性时，总是使用 static 关键字作为前缀。当类类型遵循协议时，除了 static 关键字，还可以使用 class 关键字来声明类型属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol AnotherProtocol &#123;</span><br><span class="line">    static var someTypeProperty: Int &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eg： 只有一个可读属性的协议 FullyNamed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol FullyNamed &#123;</span><br><span class="line">    var fullName: String &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遵循 FullyNamed 协议的简单结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Person: FullyNamed &#123;</span><br><span class="line">    var fullName: String</span><br><span class="line">&#125;</span><br><span class="line">let john = Person(fullName: &quot;John Appleseed&quot;)</span><br><span class="line">// john.fullName 为 &quot;John Appleseed&quot;</span><br></pre></td></tr></table></figure>
<p>fullName 为存储属性</p>
<p>下面是一个更为复杂的类，它适配并遵循了 FullyNamed 协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Starship: FullyNamed &#123;</span><br><span class="line">    var prefix: String?</span><br><span class="line">    var name: String</span><br><span class="line">    init(name: String, prefix: String? = nil) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.prefix = prefix</span><br><span class="line">    &#125;</span><br><span class="line">    var fullName: String &#123;</span><br><span class="line">        return (prefix != nil ? prefix! + &quot; &quot; : &quot;&quot;) + name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ncc1701 = Starship(name: &quot;Enterprise&quot;, prefix: &quot;USS&quot;)</span><br><span class="line">// ncc1701.fullName 是 &quot;USS Enterprise&quot;</span><br></pre></td></tr></table></figure>
<p>Starship 类把 fullName 属性实现为只读的计算型属性。</p>
<h4 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h4><p>协议可以要求遵循协议的类型实现某些指定的实例方法或类方法。这些方法作为协议的一部分，像普通方法一样放在协议的定义中，但是不需要大括号和方法体。可以在协议中定义具有可变参数的方法，和普通方法的定义方式相同。但是，不支持为协议中的方法的参数提供默认值。</p>
<p>正如属性要求中所述，在协议中定义类方法的时候，总是使用 static 关键字作为前缀。当类类型遵循协议时，除了 static 关键字，还可以使用 class 关键字作为前缀：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    static func someTypeMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的例子定义了一个只含有一个实例方法的协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol RandomNumberGenerator &#123;</span><br><span class="line">    func random() -&gt; Double</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，下边是一个遵循并符合 RandomNumberGenerator 协议的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LinearCongruentialGenerator: RandomNumberGenerator &#123;</span><br><span class="line">    var lastRandom = 42.0</span><br><span class="line">    let m = 139968.0</span><br><span class="line">    let a = 3877.0</span><br><span class="line">    let c = 29573.0</span><br><span class="line">    func random() -&gt; Double &#123;</span><br><span class="line">        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))</span><br><span class="line">        return lastRandom / m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let generator = LinearCongruentialGenerator()</span><br><span class="line">print(&quot;Here&apos;s a random number: \(generator.random())&quot;)</span><br><span class="line">// 打印 “Here&apos;s a random number: 0.37464991998171”</span><br><span class="line">print(&quot;And another one: \(generator.random())&quot;)</span><br><span class="line">// 打印 “And another one: 0.729023776863283”</span><br></pre></td></tr></table></figure>
<h4 id="异变方法要求"><a href="#异变方法要求" class="headerlink" title="异变方法要求"></a>异变方法要求</h4><p>如果你在协议中定义了一个实例方法，该方法会改变遵循该协议的类型的实例，那么在定义协议时需要在方法前加 mutating 关键字。这使得结构体和枚举能够遵循此协议并满足此方法要求。</p>
<blockquote>
<p>注意：<br>实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。</p>
</blockquote>
<p>toggle() 方法在定义的时候，使用 mutating 关键字标记，这表明当它被调用时，该方法将会改变遵循协议的类型的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol Togglable &#123;</span><br><span class="line">    mutating func toggle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面定义了一个名为 OnOffSwitch 的枚举。这个枚举在两种状态之间进行切换，用枚举成员 On 和 Off 表示。枚举的 toggle() 方法被标记为 mutating，以满足 Togglable 协议的要求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum OnOffSwitch: Togglable &#123;</span><br><span class="line">    case off, on</span><br><span class="line">    mutating func toggle() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .off:</span><br><span class="line">            self = .on</span><br><span class="line">        case .on:</span><br><span class="line">            self = .off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var lightSwitch = OnOffSwitch.off</span><br><span class="line">lightSwitch.toggle()</span><br><span class="line">// lightSwitch 现在的值为 .on</span><br></pre></td></tr></table></figure>
<h4 id="协议构造器要求的类实现"><a href="#协议构造器要求的类实现" class="headerlink" title="协议构造器要求的类实现"></a>协议构造器要求的类实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init(someParameters: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeClass: SomeProtocol &#123;</span><br><span class="line">    convenience required init(someParameters: Int) &#123;</span><br><span class="line">        self.init()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果类已经被标记为 final，那么不需要在协议构造器的实现中使用 required 修饰符，因为 final 类不能有子类。关于 final 修饰符的更多内容，请参见防止重写。</p>
</blockquote>
<p>如果一个子类重写了父类的指定构造器，并且该构造器满足了某个协议的要求，那么该构造器的实现需要同时标注 required 和 override 修饰符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeSuperClass &#123;</span><br><span class="line">    init() &#123;</span><br><span class="line">        // 这里是构造器的实现部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeSubClass: SomeSuperClass, SomeProtocol &#123;</span><br><span class="line">    // 因为遵循协议，需要加上 required</span><br><span class="line">    // 因为继承自父类，需要加上 override</span><br><span class="line">    required override init() &#123;</span><br><span class="line">        // 这里是构造器的实现部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="协议作为类型"><a href="#协议作为类型" class="headerlink" title="协议作为类型"></a>协议作为类型</h4><p>协议可以像其他普通类型一样使用，使用场景如下：</p>
<ul>
<li>作为函数、方法或构造器中的参数类型或返回值类型</li>
<li>作为常量、变量或属性的类型</li>
<li>作为数组、字典或其他容器中的元素类型</li>
</ul>
<p>下面是将协议作为类型使用的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protocol RandomNumberGenerator &#123;</span><br><span class="line">    func random() -&gt; Double</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice &#123;</span><br><span class="line">    let sides: Int</span><br><span class="line">    let generator: RandomNumberGenerator</span><br><span class="line">    init(sides: Int, generator: RandomNumberGenerator) &#123;</span><br><span class="line">        self.sides = sides</span><br><span class="line">        self.generator = generator</span><br><span class="line">    &#125;</span><br><span class="line">    func roll() -&gt; Int &#123;</span><br><span class="line">        return Int(generator.random() * Double(sides)) + 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类实现协议的 random 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class LinearCongruentialGenerator: RandomNumberGenerator &#123;</span><br><span class="line">    var lastRandom = 42.0</span><br><span class="line">    let m = 139968.0</span><br><span class="line">    let a = 3877.0</span><br><span class="line">    let c = 29573.0</span><br><span class="line">    func random() -&gt; Double &#123;</span><br><span class="line">        lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m))</span><br><span class="line">        return lastRandom / m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())</span><br><span class="line">for _ in 1...5 &#123;</span><br><span class="line">	print(&quot;Random dice roll is \(d6.roll())&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Random dice roll is 3</span><br><span class="line">// Random dice roll is 5</span><br><span class="line">// Random dice roll is 4</span><br><span class="line">// Random dice roll is 5</span><br><span class="line">// Random dice roll is 4</span><br></pre></td></tr></table></figure>
<h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现很简单：定义协议来封装那些需要被委托的功能，这样就能确保遵循协议的类型能提供这些功能。委托模式可以用来响应特定的动作，或者接收外部数据源提供的数据，而无需关心外部数据源的类型。</p>
<p>下面的例子定义了两个基于骰子游戏的协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protocol DiceGame &#123;</span><br><span class="line">    var dice: Dice &#123; get &#125;</span><br><span class="line">    func play()</span><br><span class="line">&#125;</span><br><span class="line">protocol DiceGameDelegate &#123;</span><br><span class="line">    func gameDidStart(_ game: DiceGame)</span><br><span class="line">    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int)</span><br><span class="line">    func gameDidEnd(_ game: DiceGame)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DiceGame 协议可以被任意涉及骰子的游戏遵循。DiceGameDelegate 协议可以被任意类型遵循，用来追踪 DiceGame 的游戏过程。</p>
<p>如下所示，SnakesAndLadders 是 控制流 章节引入的蛇梯棋游戏的新版本。新版本使用 Dice 实例作为骰子，并且实现了 DiceGame 和 DiceGameDelegate 协议，后者用来记录游戏的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class SnakesAndLadders: DiceGame &#123;</span><br><span class="line">    let finalSquare = 25</span><br><span class="line">    let dice = Dice(sides: 6, generator: LinearCongruentialGenerator())</span><br><span class="line">    var square = 0</span><br><span class="line">    var board: [Int]</span><br><span class="line">    init() &#123;</span><br><span class="line">        board = [Int](repeating: 0, count: finalSquare + 1)</span><br><span class="line">        board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02</span><br><span class="line">        board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08</span><br><span class="line">    &#125;</span><br><span class="line">    var delegate: DiceGameDelegate?</span><br><span class="line">    func play() &#123;</span><br><span class="line">        square = 0</span><br><span class="line">        delegate?.gameDidStart(self)</span><br><span class="line">        gameLoop: while square != finalSquare &#123;</span><br><span class="line">            let diceRoll = dice.roll()</span><br><span class="line">            delegate?.game(self, didStartNewTurnWithDiceRoll: diceRoll)</span><br><span class="line">            switch square + diceRoll &#123;</span><br><span class="line">            case finalSquare:</span><br><span class="line">                break gameLoop</span><br><span class="line">            case let newSquare where newSquare &gt; finalSquare:</span><br><span class="line">                continue gameLoop</span><br><span class="line">            default:</span><br><span class="line">                square += diceRoll</span><br><span class="line">                square += board[square]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        delegate?.gameDidEnd(self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个版本的游戏封装到了 SnakesAndLadders 类中，该类遵循了 DiceGame 协议，并且提供了相应的可读的 dice 属性和 play() 方法。（ dice 属性在构造之后就不再改变，且协议只要求 dice 为可读的，因此将 dice 声明为常量属性。）</p>
<p>游戏使用 SnakesAndLadders 类的 init() 构造器来初始化游戏。所有的游戏逻辑被转移到了协议中的 play() 方法，play() 方法使用协议要求的 dice 属性提供骰子摇出的值。</p>
<p>注意，delegate 并不是游戏的必备条件，因此 delegate 被定义为 DiceGameDelegate 类型的可选属性。因为 delegate 是可选值，因此会被自动赋予初始值 nil。随后，可以在游戏中为 delegate 设置适当的值。</p>
<p>DicegameDelegate 协议提供了三个方法用来追踪游戏过程。这三个方法被放置于游戏的逻辑中，即 play() 方法内。分别在游戏开始时，新一轮开始时，以及游戏结束时被调用。</p>
<p>因为 delegate 是一个 DiceGameDelegate 类型的可选属性，因此在 play() 方法中通过可选链式调用来调用它的方法。若 delegate 属性为 nil，则调用方法会优雅地失败，并不会产生错误。若 delegate 不为 nil，则方法能够被调用，并传递 SnakesAndLadders 实例作为参数。</p>
<p>如下示例定义了 DiceGameTracker 类，它遵循了 DiceGameDelegate 协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class DiceGameTracker: DiceGameDelegate &#123;</span><br><span class="line">    var numberOfTurns = 0</span><br><span class="line">    func gameDidStart(_ game: DiceGame) &#123;</span><br><span class="line">        numberOfTurns = 0</span><br><span class="line">        if game is SnakesAndLadders &#123;</span><br><span class="line">            print(&quot;Started a new game of Snakes and Ladders&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;The game is using a \(game.dice.sides)-sided dice&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    func game(_ game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) &#123;</span><br><span class="line">        numberOfTurns += 1</span><br><span class="line">        print(&quot;Rolled a \(diceRoll)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    func gameDidEnd(_ game: DiceGame) &#123;</span><br><span class="line">        print(&quot;The game lasted for \(numberOfTurns) turns&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DiceGameTracker 实现了 DiceGameDelegate 协议要求的三个方法，用来记录游戏已经进行的轮数。当游戏开始时，numberOfTurns 属性被赋值为 0，然后在每新一轮中递增，游戏结束后，打印游戏的总轮数。</p>
<p>gameDidStart(<em>:) 方法从 game 参数获取游戏信息并打印。game 参数是 DiceGame 类型而不是 SnakeAndLadders 类型，所以在 gameDidStart(</em>:) 方法中只能访问 DiceGame 协议中的内容。当然了，SnakeAndLadders 的方法也可以在类型转换之后调用。在上例代码中，通过 is 操作符检查 game 是否为 SnakesAndLadders 类型的实例，如果是，则打印出相应的消息。</p>
<p>无论当前进行的是何种游戏，由于 game 符合 DiceGame 协议，可以确保 game 含有 dice 属性。因此在 gameDidStart(_:) 方法中可以通过传入的 game 参数来访问 dice 属性，进而打印出 dice 的 sides 属性的值。</p>
<p>DiceGameTracker 的运行情况如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let tracker = DiceGameTracker()</span><br><span class="line">let game = SnakesAndLadders()</span><br><span class="line">game.delegate = tracker</span><br><span class="line">game.play()</span><br><span class="line">// Started a new game of Snakes and Ladders</span><br><span class="line">// The game is using a 6-sided dice</span><br><span class="line">// Rolled a 3</span><br><span class="line">// Rolled a 5</span><br><span class="line">// Rolled a 4</span><br><span class="line">// Rolled a 5</span><br><span class="line">// The game lasted for 4 turns</span><br></pre></td></tr></table></figure>
<h4 id="在扩展里添加协议遵循"><a href="#在扩展里添加协议遵循" class="headerlink" title="在扩展里添加协议遵循"></a>在扩展里添加协议遵循</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol TextRepresentable &#123;</span><br><span class="line">    var textualDescription: String &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Dice: TextRepresentable &#123;</span><br><span class="line">    var textualDescription: String &#123;</span><br><span class="line">        return &quot;A \(sides)-sided dice&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())</span><br><span class="line">print(d12.textualDescription)</span><br><span class="line">// 打印 “A 12-sided dice”</span><br></pre></td></tr></table></figure>
<p>同样，SnakesAndLadders 类也可以通过扩展遵循并符合 TextRepresentable 协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension SnakesAndLadders: TextRepresentable &#123;</span><br><span class="line">    var textualDescription: String &#123;</span><br><span class="line">        return &quot;A game of Snakes and Ladders with \(finalSquare) squares&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(game.textualDescription)</span><br><span class="line">// 打印 “A game of Snakes and Ladders with 25 squares”</span><br></pre></td></tr></table></figure>
<h4 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="headerlink" title="有条件地遵循协议"></a>有条件地遵循协议</h4><p>下面的扩展让 Array 类型只要在存储遵循 TextRepresentable 协议的元素时就遵循 TextRepresentable 协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extension Array: TextRepresentable where Element: TextRepresentable &#123;</span><br><span class="line">    var textualDescription: String &#123;</span><br><span class="line">        let itemsAsText = self.map &#123; $0.textualDescription &#125;</span><br><span class="line">        return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myDice = [d6, d12]</span><br><span class="line">print(myDice.textualDescription)</span><br><span class="line">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span><br></pre></td></tr></table></figure>
<h4 id="在扩展里声明采纳协议"><a href="#在扩展里声明采纳协议" class="headerlink" title="在扩展里声明采纳协议"></a>在扩展里声明采纳协议</h4><p>当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展采纳该协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol TextRepresentable &#123;</span><br><span class="line">    var textualDescription: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Hamster &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var textualDescription: String &#123;</span><br><span class="line">        return &quot;A hamster named \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">extension Hamster: TextRepresentable &#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>即使满足了协议的所有要求，类型也不会自动遵循协议，必须显式地遵循协议。</p>
</blockquote>
<h4 id="协议类型的集合"><a href="#协议类型的集合" class="headerlink" title="协议类型的集合"></a>协议类型的集合</h4><p>协议类型可以在数组或者字典这样的集合中使用，在协议类型提到了这样的用法。下面的例子创建了一个元素类型为 TextRepresentable 的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let things: [TextRepresentable] = [game, d12, simonTheHamster]</span><br></pre></td></tr></table></figure>
<p>如下所示，可以遍历 things 数组，并打印每个元素的文本表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for thing in things &#123;</span><br><span class="line">    print(thing.textualDescription)</span><br><span class="line">&#125;</span><br><span class="line">// A game of Snakes and Ladders with 25 squares</span><br><span class="line">// A 12-sided dice</span><br><span class="line">// A hamster named Simon</span><br></pre></td></tr></table></figure>
<p>thing 是 TextRepresentable 类型而不是 Dice，DiceGame，Hamster 等类型，即使实例在幕后确实是这些类型中的一种。由于 thing 是 TextRepresentable 类型，任何 TextRepresentable 的实例都有一个 textualDescription 属性，所以在每次循环中可以安全地访问 thing.textualDescription。</p>
<h4 id="协议的继承"><a href="#协议的继承" class="headerlink" title="协议的继承"></a>协议的继承</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol InheritingProtocol: SomeProtocol, AnotherProtocol &#123;</span><br><span class="line">    // 这里是协议的定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，PrettyTextRepresentable 协议继承了 TextRepresentable 协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol PrettyTextRepresentable: TextRepresentable &#123;</span><br><span class="line">    var prettyTextualDescription: String &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，扩展 SnakesAndLadders，使其遵循并符合 PrettyTextRepresentable 协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extension SnakesAndLadders: PrettyTextRepresentable &#123;</span><br><span class="line">    var prettyTextualDescription: String &#123;</span><br><span class="line">        var output = textualDescription + &quot;:\n&quot;</span><br><span class="line">        for index in 1...finalSquare &#123;</span><br><span class="line">            switch board[index] &#123;</span><br><span class="line">            case let ladder where ladder &gt; 0:</span><br><span class="line">                output += &quot;▲ &quot;</span><br><span class="line">            case let snake where snake &lt; 0:</span><br><span class="line">                output += &quot;▼ &quot;</span><br><span class="line">            default:</span><br><span class="line">                output += &quot;○ &quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return output</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个 PrettyTextRepresentable 类型同时也是 TextRepresentable 类型，所以在 prettyTextualDescription 的实现中，可以访问 textualDescription 属性。</p>
<h4 id="类专属的协议"><a href="#类专属的协议" class="headerlink" title="类专属的协议"></a>类专属的协议</h4><p>用 <code>class</code> 关键字， 声明该协议只能被类类型遵循。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeClassOnlyProtocol: class, SomeInheritedProtocol &#123;</span><br><span class="line">    // 这里是类专属协议的定义部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上例子中，协议 SomeClassOnlyProtocol 只能被类类型采纳。如果尝试让结构体或枚举类型采纳 SomeClassOnlyProtocol，则会导致编译时错误。</p>
<h4 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h4><p>协议组合使用 SomeProtocol &amp; AnotherProtocol 的形式。你可以列举任意数量的协议，用和符号（&amp;）分开。</p>
<p>下面的例子中，将 Named 和 Aged 两个协议按照上述语法组合成一个协议，作为函数参数的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protocol Named &#123;</span><br><span class="line">    var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">protocol Aged &#123;</span><br><span class="line">    var age: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Person: Named, Aged &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line">func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123;</span><br><span class="line">    print(&quot;Happy birthday, \(celebrator.name), you&apos;re \(celebrator.age)!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)</span><br><span class="line">// 打印 “Happy birthday Malcolm - you&apos;re 21!”</span><br></pre></td></tr></table></figure>
<p>wishHappyBirthday(to:) 函数的参数 celebrator 的类型为 Named &amp; Aged， 这意味着“任何同时遵循 Named 和 Aged 的协议”。它不关心参数的具体类型，只要参数符合这两个协议即可。</p>
<h4 id="检查协议一致性"><a href="#检查协议一致性" class="headerlink" title="检查协议一致性"></a>检查协议一致性</h4><p>检查和转换到某个协议类型在语法上和类型的检查和转换完全相同：</p>
<ul>
<li>is 用来检查实例是否符合某个协议，若符合则返回 true，否则返回 false。</li>
<li>as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil。</li>
<li>as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。</li>
</ul>
<p>下面的例子定义了一个 HasArea 协议，该协议定义了一个 Double 类型的可读属性 area：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol HasArea &#123;</span><br><span class="line">    var area: Double &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下所示，Circle 类和 Country 类都遵循了 HasArea 协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Circle: HasArea &#123;</span><br><span class="line">    let pi = 3.1415927</span><br><span class="line">    var radius: Double</span><br><span class="line">    var area: Double &#123; return pi * radius * radius &#125;</span><br><span class="line">    init(radius: Double) &#123; self.radius = radius &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Country: HasArea &#123;</span><br><span class="line">    var area: Double</span><br><span class="line">    init(area: Double) &#123; self.area = area &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Circle 类把 area 属性实现为基于存储型属性 radius 的计算型属性。Country 类则把 area 属性实现为存储型属性。这两个类都正确地符合了 HasArea 协议。</p>
<p>如下所示，Animal 是一个未遵循 HasArea 协议的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    var legs: Int</span><br><span class="line">    init(legs: Int) &#123; self.legs = legs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Circle，Country，Animal 并没有一个共同的基类，尽管如此，它们都是类，它们的实例都可以作为 AnyObject 类型的值，存储在同一个数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let objects: [AnyObject] = [</span><br><span class="line">    Circle(radius: 2.0),</span><br><span class="line">    Country(area: 243_610),</span><br><span class="line">    Animal(legs: 4)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>objects 数组使用字面量初始化，数组包含一个 radius 为 2 的 Circle 的实例，一个保存了英国国土面积的 Country 实例和一个 legs 为 4 的 Animal 实例。</p>
<p>如下所示，objects 数组可以被迭代，并对迭代出的每一个元素进行检查，看它是否符合 HasArea 协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for object in objects &#123;</span><br><span class="line">    if let objectWithArea = object as? HasArea &#123;</span><br><span class="line">        print(&quot;Area is \(objectWithArea.area)&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;Something that doesn&apos;t have an area&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Area is 12.5663708</span><br><span class="line">// Area is 243610.0</span><br><span class="line">// Something that doesn&apos;t have an area</span><br></pre></td></tr></table></figure>
<p>当它们被赋值给 objectWithArea 常量时，只被视为 HasArea 类型，因此只有 area 属性能够被访问。</p>
<h4 id="可选的协议要求"><a href="#可选的协议要求" class="headerlink" title="可选的协议要求"></a>可选的协议要求</h4><p>可选要求用在你需要和 Objective-C 打交道的代码中。协议和可选要求都必须带上 @objc 属性。标记 @objc 特性的协议只能被继承自 Objective-C 类的类或者 @objc 类遵循，其他类以及结构体和枚举均不能遵循这种协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol CounterDataSource &#123;</span><br><span class="line">    @objc optional func incrementForCount(count: Int) -&gt; Int</span><br><span class="line">    @objc optional var fixedIncrement: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CounterDataSource 协议定义了一个可选方法 increment(forCount:) 和一个可选属性 fiexdIncrement，它们使用了不同的方法来从数据源中获取适当的增量值。</p>
<p>Counter 类含有 CounterDataSource? 类型的可选属性 dataSource，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">    var dataSource: CounterDataSource?</span><br><span class="line">    func increment() &#123;</span><br><span class="line">        if let amount = dataSource?.incrementForCount?(count) &#123;</span><br><span class="line">            count += amount</span><br><span class="line">        &#125; else if let amount = dataSource?.fixedIncrement &#123;</span><br><span class="line">            count += amount</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了两层可选链式调用。首先，由于 dataSource 可能为 nil，因此在 dataSource 后边加上了 ?，以此表明只在 dataSource 非空时才去调用 increment(forCount:) 方法。其次，即使 dataSource 存在，也无法保证其是否实现了 increment(forCount:) 方法，因为这个方法是可选的。因此，increment(forCount:) 方法同样使用可选链式调用进行调用，只有在该方法被实现的情况下才能调用它，所以在 increment(forCount:) 方法后边也加上了 ?。</p>
<p>下面的例子展示了 CounterDataSource 的简单实现。ThreeSource 类遵循了 CounterDataSource 协议，它实现了可选属性 fixedIncrement，每次会返回 3：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ThreeSource: NSObject, CounterDataSource &#123;</span><br><span class="line">    let fixedIncrement = 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 ThreeSource 的实例作为 Counter 实例的数据源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var counter = Counter()</span><br><span class="line">counter.dataSource = ThreeSource()</span><br><span class="line">for _ in 1...4 &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    print(counter.count)</span><br><span class="line">&#125;</span><br><span class="line">// 3</span><br><span class="line">// 6</span><br><span class="line">// 9</span><br><span class="line">// 12</span><br></pre></td></tr></table></figure>
<p>面是一个更为复杂的数据源 TowardsZeroSource，它将使得最后的值变为 0：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@objc class TowardsZeroSource: NSObject, CounterDataSource &#123;</span><br><span class="line">    func increment(forCount count: Int) -&gt; Int &#123;</span><br><span class="line">        if count == 0 &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125; else if count &lt; 0 &#123;</span><br><span class="line">            return 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以使用 TowardsZeroSource 实例将 Counter 实例来从 -4 增加到 0。一旦增加到 0，数值便不会再有变动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">counter.count = -4</span><br><span class="line">counter.dataSource = TowardsZeroSource()</span><br><span class="line">for _ in 1...5 &#123;</span><br><span class="line">    counter.increment()</span><br><span class="line">    print(counter.count)</span><br><span class="line">&#125;</span><br><span class="line">// -3</span><br><span class="line">// -2</span><br><span class="line">// -1</span><br><span class="line">// 0</span><br><span class="line">// 0</span><br></pre></td></tr></table></figure>
<h4 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h4><p>协议可以通过扩展来为遵循协议的类型提供属性、方法以及下标的实现。通过这种方式，你可以基于协议本身来实现这些功能，而无需在每个遵循协议的类型中都重复同样的实现，也无需使用全局函数。</p>
<p>例如，可以扩展 RandomNumberGenerator 协议来提供 randomBool() 方法。该方法使用协议中定义的 random() 方法来返回一个随机的 Bool 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension RandomNumberGenerator &#123;</span><br><span class="line">    func randomBool() -&gt; Bool &#123;</span><br><span class="line">        return random() &gt; 0.5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过协议扩展，所有遵循协议的类型，都能自动获得这个扩展所增加的方法实现，无需任何额外修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let generator = LinearCongruentialGenerator()</span><br><span class="line">print(&quot;Here&apos;s a random number: \(generator.random())&quot;)</span><br><span class="line">// 打印 “Here&apos;s a random number: 0.37464991998171”</span><br><span class="line">print(&quot;And here&apos;s a random Boolean: \(generator.randomBool())&quot;)</span><br><span class="line">// 打印 “And here&apos;s a random Boolean: true”</span><br></pre></td></tr></table></figure>
<h4 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h4><blockquote>
<p>注意：<br>通过协议扩展为协议要求提供的默认实现和可选的协议要求不同。虽然在这两种情况下，遵循协议的类型都无需自己实现这些要求，但是通过扩展提供的默认实现可以直接调用，而无需使用可选链式调用。</p>
</blockquote>
<p>例如，PrettyTextRepresentable 协议继承自 TextRepresentable 协议，可以为其提供一个默认的 prettyTextualDescription 属性，只是简单地返回 textualDescription 属性的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension PrettyTextRepresentable  &#123;</span><br><span class="line">    var prettyTextualDescription: String &#123;</span><br><span class="line">        return textualDescription</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为协议扩展添加限制条件"><a href="#为协议扩展添加限制条件" class="headerlink" title="为协议扩展添加限制条件"></a>为协议扩展添加限制条件</h4><p>在扩展协议的时候，可以指定一些限制条件，只有遵循协议的类型满足这些限制条件时，才能获得协议扩展提供的默认实现。这些限制条件写在协议名之后，使用 where 子句来描述，正如泛型 Where 子句中所描述的。</p>
<p>例如，你可以扩展 Collection 协议，适用于集合中的元素遵循了 Equatable 协议的情况。通过限制集合元素遵 Equatable 协议， 作为标准库的一部分， 你可以使用 == 和 != 操作符来检查两个元素的等价性和非等价性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Collection where Element: Equatable &#123;</span><br><span class="line">    func allEqual() -&gt; Bool &#123;</span><br><span class="line">        for element in self &#123;</span><br><span class="line">            if element != self.first &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果集合中的所有元素都一致，allEqual() 方法才返回 true。</p>
<p>【 参考 梁杰 极客学院 】</p>

  </section>

</article>

<section class="read-more">
           
    
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2019/01/04/Swift-入门-第-21-课-扩展/" title="Swift 入门 第 21 课 扩展">Swift 入门 第 21 课 扩展</a></h2>
                <p class="excerpt">
                
                扩展是为已有的类型，如 结构体、枚举、类添加新的功能。 没有权限获取原始代码的情况下扩展类型的能力。与 Object-C 的分类类似。不同的是 Swift 的扩展没有名字。
Swift 中的扩展可以：

添加计算型属性和计算型类型属性
定义实例方法和类型方法
提供新的构造器
定义下标
定义和使用新的
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2019-01-04T01:09:40.343Z" class="post-list__meta--date date">2019-01-04</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2019/01/04/Swift-入门-第-21-课-扩展/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2019 徐雪勇 - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
