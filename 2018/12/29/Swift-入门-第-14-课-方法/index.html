<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Swift 入门 第 14 课 方法 | 云山之处</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="像写诗一样, 将写代码作为一门艺术.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Swift 入门 第 14 课 方法 | 云山之处">
    <meta name="twitter:description" content="像写诗一样, 将写代码作为一门艺术.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Swift 入门 第 14 课 方法 | 云山之处">
    <meta property="og:description" content="像写诗一样, 将写代码作为一门艺术.">

    
    <meta name="author" content="徐雪勇">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="云山之处" href="/atom.xml">
    

    <link rel="canonical" href="http://xuxueyong.github.io/2018/12/29/Swift-入门-第-14-课-方法/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 云山之处 的主页"><img src="/images/avatar.jpg" width="80" alt="云山之处 logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 云山之处">云山之处</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">最好的时代, 活出最好的自己</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">像写诗一样, 将写代码作为一门艺术.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="https://www.jianshu.com/u/823519e76f1a">简书</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
              <li class="navigation__item"><a href="/favourite/image.html">幻想间</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/u/2506861343?is_all=1" title="Weibo" target="_blank">
      <i class="social fa fa-weibo"></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/xuxueyong" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-blue"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-12-29T06:20:12.217Z" class="post-list__meta--date date">2018-12-29</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Swift 入门 第 14 课 方法</h1>
  </header>

  <section class="post">
    <p>方法是与某些特定类型相关联的函数， 类、结构体、枚举都可以为实例定义， 实例方法， 也可以为类型定义类型方法， 类型方法和 Object-C 中的类方法类似。</p>
<p>Object-C 的结构体和枚举是不能定义实例方法和类型方法的。</p>
<h4 id="实例方法（Instance-Methods）"><a href="#实例方法（Instance-Methods）" class="headerlink" title="实例方法（Instance Methods）"></a>实例方法（Instance Methods）</h4><p>实例方法和函数的语法一样</p>
<p>实例方法定义在类型的括号之间，实例方法能够访问实例的其他方法和属性。实例方法只能被它所属的类型的特定实例调用。</p>
<p>下面的例子，定义一个很简单的 Counter 类，Counter 能被用来对一个动作发生的次数进行计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Counter &#123;</span><br><span class="line">    var count = 0</span><br><span class="line">    func increment() &#123;</span><br><span class="line">        count += 1</span><br><span class="line">    &#125;</span><br><span class="line">    func increment(by amount: Int) &#123;</span><br><span class="line">        count += amount</span><br><span class="line">    &#125;</span><br><span class="line">    func reset() &#123;</span><br><span class="line">        count = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Counter 类定义了三个实例方法：</p>
<ul>
<li>increment 让计数器按一递增；</li>
<li>increment(by: Int) 让计数器按一个指定的整数值递增；</li>
<li>reset 将计数器重置为0。<br>Counter 这个类还声明了一个可变属性 count，用它来保持对当前计数器值的追踪。</li>
</ul>
<p>和调用属性一样，用点语法（dot syntax）调用实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let counter = Counter()</span><br><span class="line">// 初始计数值是0</span><br><span class="line">counter.increment()</span><br><span class="line">// 计数值现在是1</span><br><span class="line">counter.increment(by: 5)</span><br><span class="line">// 计数值现在是6</span><br><span class="line">counter.reset()</span><br><span class="line">// 计数值现在是0</span><br></pre></td></tr></table></figure>
<p>函数有一个参数 和 外部标签， 调用时使用外部标签。 方法参数与函数一样， 只是方法与某个类型相关联了。</p>
<h4 id="self-属性"><a href="#self-属性" class="headerlink" title="self 属性"></a>self 属性</h4><p>每一个实例都有一个隐藏属性 self， 等同于实例本身， 可以在方法中使用 self 来引用实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func increment() &#123;</span><br><span class="line">    self.count += 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上在代码里不用写 self， 不写的时候，在方法中使用实例属性， 默认就是使用的 self 的属性。<br>上面的 count 都没有使用 self.count。</p>
<p>当实例方法的参数名称和实例名称相同的时候， 必须要使用 self， 否则编译器不知道那个是实例属性。在这种情况下， 参数名称享有优先权。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    func isToTheRightOfX(_ x: Double) -&gt; Bool &#123;</span><br><span class="line">        return self.x &gt; x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let somePoint = Point(x: 4.0, y: 5.0)</span><br><span class="line">if somePoint.isToTheRightOfX(1.0) &#123;</span><br><span class="line">    print(&quot;This point is to the right of the line where x == 1.0&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;This point is to the right of the line where x == 1.0&quot;</span><br></pre></td></tr></table></figure>
<h5 id="在实例方法中修改值类型"><a href="#在实例方法中修改值类型" class="headerlink" title="在实例方法中修改值类型"></a>在实例方法中修改值类型</h5><p>结构体和枚举是值类型。默认情况下，值类型的属性不能在它的实例方法中被修改。</p>
<p>但是，如果你确实需要在某个特定的方法中修改结构体或者枚举的属性，你可以为这个方法选择 可变（mutating）行为，然后就可以从其方法内部改变它的属性；并且这个方法做的任何改变都会在方法执行结束时写回到原始结构中。方法还可以给它隐含的 self 属性赋予一个全新的实例，这个新实例在方法结束时会替换现存实例。</p>
<p>要使用 可变方法，将关键字 mutating 放到方法的 func 关键字之前就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    mutating func moveByX(_ deltaX: Double, y deltaY: Double) &#123;</span><br><span class="line">        x += deltaX</span><br><span class="line">        y += deltaY</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var somePoint = Point(x: 1.0, y: 1.0)</span><br><span class="line">somePoint.moveByX(2.0, y: 3.0)</span><br><span class="line">print(&quot;The point is now at (\(somePoint.x), \(somePoint.y))&quot;)</span><br><span class="line">// 打印 &quot;The point is now at (3.0, 4.0)&quot;</span><br></pre></td></tr></table></figure>
<p>上面的 Point 结构体定义了一个可变方法 moveByX(_:y:) 来移动 Point 实例到给定的位置。该方法被调用时修改了这个点，而不是返回一个新的点。方法定义时加上了 mutating 关键字，从而允许修改属性。</p>
<p>注意，不能在结构体类型的常量（a constant of structure type）上调用可变方法，因为其属性不能被改变，即使属性是变量属性，详情参见常量结构体的存储属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fixedPoint = Point(x: 3.0, y: 3.0)</span><br><span class="line">fixedPoint.moveByX(2.0, y: 3.0)</span><br><span class="line">// 这里将会报告一个错误</span><br></pre></td></tr></table></figure>
<h4 id="在可变方法中给-self-赋值"><a href="#在可变方法中给-self-赋值" class="headerlink" title="在可变方法中给 self 赋值"></a>在可变方法中给 self 赋值</h4><p>可变方法能够赋给隐含属性 self 一个全新的实例。上面 Point 的例子可以用下面的方式改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0, y = 0.0</span><br><span class="line">    mutating func moveBy(x deltaX: Double, y deltaY: Double) &#123;</span><br><span class="line">        self = Point(x: x + deltaX, y: y + deltaY)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举的可变方法可以把 self 设置为同一枚举类型中不同的成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">enum TriStateSwitch &#123;</span><br><span class="line">    case Off, Low, High</span><br><span class="line">    mutating func next() &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .Off:</span><br><span class="line">            self = .Low</span><br><span class="line">        case .Low:</span><br><span class="line">            self = .High</span><br><span class="line">        case .High:</span><br><span class="line">            self = .Off</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ovenLight = TriStateSwitch.Low</span><br><span class="line">ovenLight.next()</span><br><span class="line">// ovenLight 现在等于 .High</span><br><span class="line">ovenLight.next()</span><br><span class="line">// ovenLight 现在等于 .Off</span><br></pre></td></tr></table></figure>
<p>上面的例子中定义了一个三态开关的枚举。每次调用 next() 方法时，开关在不同的电源状态（Off，Low，High）之间循环切换。</p>
<h4 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h4><p>定义在类型本身上调用的方法，这种方法就叫做类型方法。</p>
<p>定义在类型本身上调用的方法，这种方法就叫做类型方法。在方法的 func 关键字之前加上关键字 static，来指定类型方法。<strong>类还可以用关键字 class 来允许子类重写父类的方法实现。</strong></p>
<p>SomeClass 类上调用类型方法的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line">    class func someTypeMethod() &#123;</span><br><span class="line">        // 在这里实现类型方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SomeClass.someTypeMethod()</span><br></pre></td></tr></table></figure>
<p>一个类型方法可以直接通过类型方法的名称调用本类中的其它类型方法，而无需在方法名称前面加上类型名称。类似地，在结构体和枚举中，也能够直接通过类型属性的名称访问本类中的类型属性，而不需要前面加上类型名称。</p>
<p>下面的例子定义了一个名为 LevelTracker 结构体。它监测玩家的游戏发展情况（游戏的不同层次或阶段）。这是一个单人游戏，但也可以存储多个玩家在同一设备上的游戏信息。</p>
<p>游戏初始时，所有的游戏等级（除了等级 1）都被锁定。每次有玩家完成一个等级，这个等级就对这个设备上的所有玩家解锁。LevelTracker 结构体用类型属性和方法监测游戏的哪个等级已经被解锁。它还监测每个玩家的当前等级。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct LevelTracker &#123;</span><br><span class="line">    static var highestUnlockedLevel = 1</span><br><span class="line">    var currentLevel = 1</span><br><span class="line"></span><br><span class="line">    static func unlock(_ level: Int) &#123;</span><br><span class="line">        if level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func isUnlocked(_ level: Int) -&gt; Bool &#123;</span><br><span class="line">        return level &lt;= highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @discardableResult</span><br><span class="line">    mutating func advance(to level: Int) -&gt; Bool &#123;</span><br><span class="line">        if LevelTracker.isUnlocked(level) &#123;</span><br><span class="line">            currentLevel = level</span><br><span class="line">            return true</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LevelTracker 监测玩家已解锁的最高等级。这个值被存储在类型属性 highestUnlockedLevel 中。</p>
<p>LevelTracker 还定义了两个类型方法与 highestUnlockedLevel 配合工作。第一个类型方法是 unlock(<em>:)，一旦新等级被解锁，它会更新 highestUnlockedLevel 的值。第二个类型方法是 isUnlocked(</em>:)，如果某个给定的等级已经被解锁，它将返回 true。（注意，尽管我们没有使用类似 LevelTracker.highestUnlockedLevel 的写法，这个类型方法还是能够访问类型属性 highestUnlockedLevel）</p>
<p>除了类型属性和类型方法，LevelTracker 还监测每个玩家的进度。它用实例属性 currentLevel 来监测每个玩家当前的等级。</p>
<p>为了便于管理 currentLevel 属性，LevelTracker 定义了实例方法 advance(to:)。这个方法会在更新 currentLevel 之前检查所请求的新等级是否已经解锁。advance(to:) 方法返回布尔值以指示是否能够设置 currentLevel。因为允许在调用 advance(to:) 时候忽略返回值，不会产生编译警告，所以函数被标注为 @ discardableResult 属性，更多关于属性信息，请参考属性章节。</p>
<p>下面，Player 类使用 LevelTracker 来监测和更新每个玩家的发展进度：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Player &#123;</span><br><span class="line">    var tracker = LevelTracker()</span><br><span class="line">    let playerName: String</span><br><span class="line">    func complete(level: Int) &#123;</span><br><span class="line">        LevelTracker.unlock(level + 1)</span><br><span class="line">        tracker.advance(to: level + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        playerName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Player 类创建一个新的 LevelTracker 实例来监测这个用户的进度。它提供了 complete(level:) 方法，一旦玩家完成某个指定等级就调用它。这个方法为所有玩家解锁下一等级，并且将当前玩家的进度更新为下一等级。（我们忽略了 advance(to:) 返回的布尔值，因为之前调用 LevelTracker.unlock(_:) 时就知道了这个等级已经被解锁了）。</p>
<p>你还可以为一个新的玩家创建一个 Player 的实例，然后看这个玩家完成等级一时发生了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var player = Player(name: &quot;Argyrios&quot;)</span><br><span class="line">player.complete(level: 1)</span><br><span class="line">print(&quot;highest unlocked level is now \(LevelTracker.highestUnlockedLevel)&quot;)</span><br><span class="line">// 打印 &quot;highest unlocked level is now 2&quot;</span><br></pre></td></tr></table></figure>
<p>如果你创建了第二个玩家，并尝试让他开始一个没有被任何玩家解锁的等级，那么试图设置玩家当前等级将会失败：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">player = Player(name: &quot;Beto&quot;)</span><br><span class="line">if player.tracker.advance(to: 6) &#123;</span><br><span class="line">    print(&quot;player is now on level 6&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;level 6 has not yet been unlocked&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;level 6 has not yet been unlocked&quot;</span><br></pre></td></tr></table></figure>
<p>【 参考 梁杰 极客学院 】</p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Newer Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/12/29/Swift-入门-第-15-课-下标/" title="Swift 入门 第 15 课 下标">Swift 入门 第 15 课 下标</a></h2>
                <p class="excerpt">
                
                下标语法下标允许你在实例后的方括号中， 传入一个或多个索引值来对实例进行存取。 定义下标使用 subscript 关键字，指定一个或多个输入参数和返回类型；与实例方法不同的是，下标可以设定为读写或只读。这种行为由 getter 和 setter 实现，有点类似计算型属性：
123456789subs
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-12-29T08:28:59.303Z" class="post-list__meta--date date">2018-12-29</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/12/29/Swift-入门-第-15-课-下标/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/12/29/Swift-入门-第-13-课-属性/" title="Swift 入门 第 13 课 属性">Swift 入门 第 13 课 属性</a></h2>
                <p class="excerpt">
                
                存储属性存储变量和常量作为实例的一部分。计算属性计算（而不是存储）一个值。 计算属性用于类结构体和枚举，存储属性用于类和结构体。
存储属性一般和特定的实例关联， 但是属性也能与类关联， 被称为类属性。
可以定义属性观察器，用来观察属性的变化， 做一些自定义操作。可以添加在存储属性上， 也可以添加在父
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-12-29T02:28:37.743Z" class="post-list__meta--date date">2018-12-29</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/12/29/Swift-入门-第-13-课-属性/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 徐雪勇 - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
