<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Swift 入门 第 4 课 字符串和字符 | 云山之处</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="像写诗一样, 将写代码作为一门艺术.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Swift 入门 第 4 课 字符串和字符 | 云山之处">
    <meta name="twitter:description" content="像写诗一样, 将写代码作为一门艺术.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Swift 入门 第 4 课 字符串和字符 | 云山之处">
    <meta property="og:description" content="像写诗一样, 将写代码作为一门艺术.">

    
    <meta name="author" content="徐雪勇">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.png">
    

    <meta name="generator" content="hexo"/>
    
    <link rel="alternate" type="application/rss+xml" title="云山之处" href="/atom.xml">
    

    <link rel="canonical" href="http://xuxueyong.github.io/2018/12/26/Swift-入门-第-4-课-字符串和字符/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 云山之处 的主页"><img src="/images/avatar.jpg" width="80" alt="云山之处 logo" class="panel-cover__logo logo"></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for 云山之处">云山之处</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">最好的时代, 活出最好的自己</span>
        
        <hr class="panel-cover__divider">
        <p class="panel-cover__description">像写诗一样, 将写代码作为一门艺术.</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="Visit the blog" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="https://www.jianshu.com/u/823519e76f1a">简书</a></li>
            
              <li class="navigation__item"><a href="/favourite/time.html">时光机</a></li>
            
              <li class="navigation__item"><a href="/favourite/image.html">幻想间</a></li>
            
              <li class="navigation__item"><a href="/aboutme">关于我</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="https://weibo.com/u/2506861343?is_all=1" title="Weibo" target="_blank">
      <i class="social fa fa-weibo"></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/xuxueyong" title="GitHub" target="_blank">
      <i class="social fa fa-github"></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  

  <li class="navigation__item">
    <a href="/atom.xml" title="RSS" target="_blank">
      <i class="social fa fa-rss"></i>
      <span class="label">RSS</span>
    </a>
  </li>



  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-blue"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2018-12-26T03:38:32.954Z" class="post-list__meta--date date">2018-12-26</time> &#8226; <span class="post-meta__tags tags">于  </span>
      <span class="page-pv">
       Read <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Swift 入门 第 4 课 字符串和字符</h1>
  </header>

  <section class="post">
    <p>Swift 的 String 和 Character 类型提供了快速和兼容 Unicode 的方式供你的代码使用。<br>每一个字符串都是由编码无关的 Unicode 字符组成，并支持访问字符的多种 Unicode 表示形式。</p>
<blockquote>
<p>注意：<br>Swift 的 String 类型 与 NSString 进行了无缝桥接， 可以扩展 String 类型， 对 NSString 中暴露的方法进行调用。 后面举例说明</p>
</blockquote>
<h4 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h4><p>字符串字面量是有一对双引号包裹着的一对有序的字符集合组成。</p>
<p>字符串字面量可以初始化常量或变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let someString = &quot;Some string literal value&quot;</span><br></pre></td></tr></table></figure>
<p>someString 通过 “Some string literal value” 字面量进行初始化， Swift 推断类型为 String</p>
<h4 id="多行字符串字面量"><a href="#多行字符串字面量" class="headerlink" title="多行字符串字面量"></a>多行字符串字面量</h4><p>如果你需要一个跨越多行的字符串字面量， 使用三队双引号包裹即可实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let quotation = &quot;&quot;&quot;</span><br><span class="line">The White Rabbit put on his spectacles.  &quot;Where shall I begin,</span><br><span class="line">please your Majesty?&quot; he asked.</span><br><span class="line"></span><br><span class="line">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on</span><br><span class="line">till you come to the end; then stop.&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>如果你不想在打印和显示后换行， 但是编辑的时候想换行， 我们可以使用一个续行符反斜杠（\）.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let softWrappedQuotation = &quot;&quot;&quot;</span><br><span class="line">The White Rabbit put on his spectacles.  &quot;Where shall I begin, \</span><br><span class="line">please your Majesty?&quot; he asked.</span><br><span class="line"></span><br><span class="line">&quot;Begin at the beginning,&quot; the King said gravely, &quot;and go on \</span><br><span class="line">till you come to the end; then stop.&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>如果想在行首和行尾各留出一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let lineBreaks = &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">This string starts with a line break.</span><br><span class="line">It also ends with a line break.</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="字符串字面量的特殊字符"><a href="#字符串字面量的特殊字符" class="headerlink" title="字符串字面量的特殊字符"></a>字符串字面量的特殊字符</h4><p>字符串字面量可以包含以下特殊字符</p>
<ul>
<li>转义字符 \0(空字符)、\(反斜线)、\t(水平制表符)、\n(换行符)、\r(回车符)、\”(双引号)、\’(单引号)。</li>
<li>Unicode 标量，写成 \u{n}(u 为小写)，其中 n 为任意一到八位十六进制数且可用的 Unicode 位码。</li>
</ul>
<p>下面的代码为各种特殊字符的使用示例。 wiseWords 常量包含了两个双引号。 dollarSign、blackHeart 和 sparklingHeart 常量演示了三种不同格式的 Unicode 标量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let wiseWords = &quot;\&quot;Imagination is more important than knowledge\&quot; - Einstein&quot;</span><br><span class="line">// &quot;Imageination is more important than knowledge&quot; - Enistein</span><br><span class="line">let dollarSign = &quot;\u&#123;24&#125;&quot;             // $，Unicode 标量 U+0024</span><br><span class="line">let blackHeart = &quot;\u&#123;2665&#125;&quot;           // ♥，Unicode 标量 U+2665</span><br><span class="line">let sparklingHeart = &quot;\u&#123;1F496&#125;&quot;      // 💖，Unicode 标量 U+1F496</span><br></pre></td></tr></table></figure>
<p>在多行字符串字面量中，使用双引号不需要转义符 <code>\</code> 但是要在里面使用三个引号， 就需要使用转义符 <code>、</code> 了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let threeDoubleQuotes = &quot;&quot;&quot;</span><br><span class="line">Escaping the first quote \&quot;&quot;&quot;</span><br><span class="line">Escaping all three quotes \&quot;\&quot;\&quot;</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<h4 id="初始化空字符串"><a href="#初始化空字符串" class="headerlink" title="初始化空字符串"></a>初始化空字符串</h4><p>可以通过一个空字符串字面量， 或者使用String 实例来初始化一个字符串变量或常量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var emptyString = &quot;&quot;               // 空字符串字面量</span><br><span class="line">var anotherEmptyString = String()  // 初始化方法</span><br><span class="line">// 两个字符串均为空并等价。</span><br></pre></td></tr></table></figure>
<p>可以通过判断 String 类型的 isEmpty 属性来判断是否为空</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if emptyString.isEmpty &#123;</span><br><span class="line">    print(&quot;Nothing to see here&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印输出：&quot;Nothing to see here&quot;</span><br></pre></td></tr></table></figure>
<h4 id="字符串可变性"><a href="#字符串可变性" class="headerlink" title="字符串可变性"></a>字符串可变性</h4><p>用 var 声明将可变， let 声明将不可变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var variableString = &quot;Horse&quot;</span><br><span class="line">variableString += &quot; and carriage&quot;</span><br><span class="line">// variableString 现在为 &quot;Horse and carriage&quot;</span><br><span class="line"></span><br><span class="line">let constantString = &quot;Highlander&quot;</span><br><span class="line">constantString += &quot; and another Highlander&quot;</span><br><span class="line">// 这会报告一个编译错误（compile-time error） - 常量字符串不可以被修改。</span><br></pre></td></tr></table></figure>
<h4 id="字符串是值类型"><a href="#字符串是值类型" class="headerlink" title="字符串是值类型"></a>字符串是值类型</h4><p>Swift 的 String 类型是值类型。在函数或者方法中传递时， 都是重新拷贝一份副本， 和原来的值不会有关系。</p>
<p>在实际编译时， Swift 会优化字符串的使用， 使实际的复制， 只发生在绝对必要的情况下， 这将极大的提高了程序的性能。</p>
<h4 id="使用字符"><a href="#使用字符" class="headerlink" title="使用字符"></a>使用字符</h4><p>可以通过 <code>for in</code> 来遍历出每一个字符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for character in &quot;Dog!🐶&quot; &#123;</span><br><span class="line">    print(character)</span><br><span class="line">&#125;</span><br><span class="line">// D</span><br><span class="line">// o</span><br><span class="line">// g</span><br><span class="line">// !</span><br><span class="line">// 🐶</span><br></pre></td></tr></table></figure>
<p>声明一个字符类型 通过 <code>Character</code> 关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let exclamationMark: Character = &quot;!&quot;</span><br></pre></td></tr></table></figure>
<p>通过传入一个字符数组来初始化一个 <code>String</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;🐱&quot;]</span><br><span class="line">let catString = String(catCharacters)</span><br><span class="line">print(catString)</span><br><span class="line">// 打印输出：&quot;Cat!🐱&quot;</span><br></pre></td></tr></table></figure>
<h4 id="连接字符串和字符"><a href="#连接字符串和字符" class="headerlink" title="连接字符串和字符"></a>连接字符串和字符</h4><p>通过 <code>+</code> 号 连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let string1 = &quot;hello&quot;</span><br><span class="line">let string2 = &quot; there&quot;</span><br><span class="line">var welcome = string1 + string2</span><br><span class="line">// welcome 现在等于 &quot;hello there&quot;</span><br></pre></td></tr></table></figure>
<p>通过 <code>+=</code> 链接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var instruction = &quot;look over&quot;</span><br><span class="line">instruction += string2</span><br><span class="line">// instruction 现在等于 &quot;look over there&quot;</span><br></pre></td></tr></table></figure>
<p>通过 <code>append</code> 将一个字符或字符串添加在尾部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let exclamationMark: Character = &quot;!&quot;</span><br><span class="line">welcome.append(exclamationMark)</span><br><span class="line">// welcome 现在等于 &quot;hello there!&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>你不能将一个字符和字符串，添加在一个已经存在的字符变量上。</p>
</blockquote>
<h4 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h4><p>字符串插值， 是一种新建字符串的方式， 可以在其中包含 常量、变量、字面量、表达式等。 字符串字面量和多行字符串字面量都可以使用字符串插值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let multiplier = 3</span><br><span class="line">let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot;</span><br><span class="line">// message 是 &quot;3 times 2.5 is 7.5&quot;</span><br></pre></td></tr></table></figure>
<h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><p>Unicode是一个国际标准，用于文本的编码和表示。 它使您可以用标准格式表示来自任意语言几乎所有的字符，并能够对文本文件或网页这样的外部资源中的字符进行读写操作。 Swift 的 String 和 Character 类型是完全兼容 Unicode 标准的。</p>
<h4 id="Unicode-标量"><a href="#Unicode-标量" class="headerlink" title="Unicode 标量"></a>Unicode 标量</h4><p>Swift 的 String 类型是基于 Unicode 标量 建立的。 Unicode 标量是对应字符或者修饰符的唯一的21位数字，例如 U+0061 表示小写的拉丁字母（LATIN SMALL LETTER A）（”a”），U+1F425 表示小鸡表情（FRONT-FACING BABY CHICK）（”🐥”）。</p>
<blockquote>
<p>注意<br>Unicode 码位（code poing） 的范围是 U+0000 到 U+D7FF 或者 U+E000 到 U+10FFFF。Unicode 标量不包括 Unicode 代理项（surrogate pair） 码位，其码位范围是 U+D800 到 U+DFFF。</p>
</blockquote>
<p>注意不是所有的21位 Unicode 标量都代表一个字符，因为有一些标量是留作未来分配的。已经代表一个典型字符的标量都有自己的名字，例如上面例子中的 LATIN SMALL LETTER A 和 FRONT-FACING BABY CHICK。</p>
<h4 id="可扩展的字形群集"><a href="#可扩展的字形群集" class="headerlink" title="可扩展的字形群集"></a>可扩展的字形群集</h4><p>Swift 的 Character 类型 代表一个可扩展的子形群。<br>一个可扩展的字形群是一个或多个可生成人类可读的字符 Unicode 标量的有序排列。<br>eg： e 和  ́</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">字符串写法</span><br><span class="line">let x = &quot;\u&#123;0065&#125;&quot;</span><br><span class="line">let y = &quot;\u&#123;301&#125;&quot;</span><br><span class="line">let welcome = x + y</span><br><span class="line">print(x, y)</span><br><span class="line">print(welcome)</span><br><span class="line">// e  ́</span><br><span class="line">// é</span><br><span class="line"></span><br><span class="line">// 第二种 Character 写法  eAcute 的值 和 z 的值一样 都是一个 `Character` 类型的 é</span><br><span class="line">let eAcute: Character = &quot;\u&#123;E9&#125;&quot; </span><br><span class="line">let z: Character = &quot;\u&#123;0065&#125;\u&#123;301&#125;&quot;</span><br><span class="line">print(type(of: z))</span><br><span class="line">print(z)</span><br><span class="line">// Character</span><br><span class="line">// é</span><br></pre></td></tr></table></figure>
<p>可扩展的字符群集是一个灵活的方法，用许多复杂的脚本字符表示单一的 Character 值。 例如，来自朝鲜语字母表的韩语音节能表示为组合或分解的有序排列。 在 Swift 都会表示为同一个单一的 Character 值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let precomposed: Character = &quot;\u&#123;D55C&#125;&quot;                  // 한</span><br><span class="line">let decomposed: Character = &quot;\u&#123;1112&#125;\u&#123;1161&#125;\u&#123;11AB&#125;&quot;   // ᄒ, ᅡ, ᆫ</span><br><span class="line">print(precomposed,decomposed, separator: &quot;,&quot;)</span><br><span class="line">// 한,한</span><br></pre></td></tr></table></figure>
<p>可拓展的字符群集可以使包围记号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let enclosedEAcute: Character = &quot;\u&#123;E9&#125;\u&#123;20DD&#125;&quot;</span><br><span class="line">// enclosedEAcute 是 é⃝</span><br></pre></td></tr></table></figure>
<p>地域性指示符号的 Unicode 标量可以组合成一个单一的 Character 值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let regionalIndicatorForUS: Character = &quot;\u&#123;1F1FA&#125;\u&#123;1F1F8&#125;&quot;</span><br><span class="line">// regionalIndicatorForUS 是 🇺🇸</span><br><span class="line">// \u&#123;1F1FA&#125; 🇺</span><br><span class="line">// \u&#123;1F1F8&#125; 🇸</span><br></pre></td></tr></table></figure>
<h4 id="计算字符数量"><a href="#计算字符数量" class="headerlink" title="计算字符数量"></a>计算字符数量</h4><p>使用 String 类型的属性 count 可以计算出 Character 的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let unusualMenagerie = &quot;Koala 🐨, Snail 🐌, Penguin 🐧, Dromedary 🐪&quot;</span><br><span class="line">print(&quot;unusualMenagerie has \(unusualMenagerie.count) characters&quot;)</span><br><span class="line">// 打印输出 &quot;unusualMenagerie has 40 characters&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>在 Swift 中，使用可拓展的字符群集作为 Character 值来连接或改变字符串时，并不一定会更改字符串的字符数量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> let gg: Character = &quot;\u&#123;1F1FA&#125;&quot;</span><br><span class="line">let hh: Character = &quot;\u&#123;1F1F8&#125;&quot;</span><br><span class="line">let s1 = String([gg, hh])</span><br><span class="line"></span><br><span class="line">let regionalIndicatorForUS: Character = &quot;\u&#123;1F1FA&#125;\u&#123;1F1F8&#125;&quot;</span><br><span class="line">let s2 = String(regionalIndicatorForUS)</span><br><span class="line">print(s1.count)</span><br><span class="line">print(s2.count)</span><br><span class="line">// s1 的count 值为 1</span><br><span class="line">// s2 的count 值为 1</span><br></pre></td></tr></table></figure>
<p>给末尾的字符加音标， 字符数量个数没有增加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var word = &quot;cafe&quot;</span><br><span class="line">print(&quot;the number of characters in \(word) is \(word.count)&quot;)</span><br><span class="line">// 打印输出 &quot;the number of characters in cafe is 4&quot;</span><br><span class="line"></span><br><span class="line">word += &quot;\u&#123;301&#125;&quot;    // 拼接一个重音，U+0301</span><br><span class="line"></span><br><span class="line">print(&quot;the number of characters in \(word) is \(word.count)&quot;)</span><br><span class="line">// 打印输出 &quot;the number of characters in café is 4&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意<br>可扩展的字符群集可以组成一个或者多个 Unicode 标量。这意味着不同的字符以及相同字符的不同表示方式可能需要不同数量的内存空间来存储。所以 Swift 中的字符在一个字符串中并不一定占用相同的内存空间数量。因此在没有获取字符串的可扩展的字符群的范围时候，就不能计算出字符串的字符数量。如果您正在处理一个长字符串，需要注意 count 属性必须遍历全部的 Unicode 标量，来确定字符串的字符数量。另外需要注意的是通过 count 属性返回的字符数量并不总是与包含相同字符的 NSString 的 length 属性相同。NSString 的 length 属性是利用 UTF-16 表示的十六位代码单元数字，而不是 Unicode 可扩展的字符群集。</p>
</blockquote>
<h4 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h4><p>String 类型是由 Unicode 标量建立的， 不同Unicode 标量表示的方式， 会造成内存使用也不一样， 所以， String 不能以整数类型 Int 值作为索引值。 String 的索引时以 String.Index 类型来表示的， 它能够遍历完每一个 Unicode 标量。</p>
<p>通过调用 String 的 index(before:) 或 index(after:) 方法，可以立即得到前面或后面的一个索引。您还可以通过调用 index(_:offsetBy:) 方法来获取对应偏移量的索引。</p>
<p>你可以使用下标语法来访问 String 特定索引的 Character。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let greeting = &quot;Guten Tag!&quot;</span><br><span class="line">greeting[greeting.startIndex]</span><br><span class="line">// G</span><br><span class="line">greeting[greeting.index(before: greeting.endIndex)]</span><br><span class="line">// !</span><br><span class="line">greeting[greeting.index(after: greeting.startIndex)]</span><br><span class="line">// u</span><br><span class="line">let index = greeting.index(greeting.startIndex, offsetBy: 7)</span><br><span class="line">greeting[index]</span><br><span class="line">// a</span><br></pre></td></tr></table></figure>
<p>如果索引值越界， 将会产生运行时错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">greeting[greeting.endIndex] // error</span><br><span class="line">greeting.index(after: endIndex) // error</span><br></pre></td></tr></table></figure>
<p>使用 indices 属性会创建一个包含全部索引的范围（Range），用来在一个字符串中访问单个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;hello world!!&quot;</span><br><span class="line">for index in str.indices &#123;</span><br><span class="line">	print(str[index])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>调用 insert(_:at:) 方法可以在一个字符串的指定索引插入一个字符，调用 insert(contentsOf:at:) 方法可以在一个字符串的指定索引插入一个段字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var welcome = &quot;hello&quot;</span><br><span class="line">welcome.insert(&quot;!&quot;, at: welcome.endIndex)</span><br><span class="line">// welcome 变量现在等于 &quot;hello!&quot;</span><br><span class="line"></span><br><span class="line">welcome.insert(contentsOf:&quot; there&quot;, at: welcome.index(before: welcome.endIndex))</span><br><span class="line">// welcome 变量现在等于 &quot;hello there!&quot;</span><br></pre></td></tr></table></figure>
<p>调用 remove(at:) 方法可以在一个字符串的指定索引删除一个字符，调用 removeSubrange(_:) 方法可以删除一个区间内的子字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">welcome.remove(at: welcome.index(before: welcome.endIndex))</span><br><span class="line">// welcome 现在等于 &quot;hello there&quot;</span><br><span class="line"></span><br><span class="line">let range = welcome.index(welcome.endIndex, offsetBy: -6)..&lt;welcome.endIndex</span><br><span class="line">welcome.removeSubrange(range)</span><br><span class="line">// welcome 现在等于 &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<h4 id="子字符串"><a href="#子字符串" class="headerlink" title="子字符串"></a>子字符串</h4><p>子字符串是 通过 String 的 prefix 等方法， 获取到的 SubString 类型的字符串。 SubString 可以使用 String 的方法。 但是 SubString 只适合短时间内的存储， 如果想要 SubString 长期存储， 还是要转化为 String 类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let greeting = &quot;greet, hello&quot;</span><br><span class="line">let index = greeting.index(of: &quot;,&quot;) ?? greeting.endIndex</span><br><span class="line">let range = ..&lt;index</span><br><span class="line">let beginning = greeting[range]</span><br><span class="line">        </span><br><span class="line">let newString = String(beginning)   // 转化为 String 长期存储</span><br><span class="line">print(newString)</span><br><span class="line">// greet</span><br></pre></td></tr></table></figure>
<p>SubString 会共用 String 的内从空间。(String 也有同样的优化， 如果String 共用内存空间， 意味着它们相等的)。 这就是说在 SubString 或 String 改变之前， 内存的复制是不会发生的。就是前面讲的 SubString 不适合长期存储， 因为 SubString 重用的是 String 的内存空间，所以 String 的内存空间必须保留到， SubString 不再使用为止。</p>
<blockquote>
<p>主要：<br>SubString 和 String 都遵循 StringProtocol 协议。 所以调用方法时， 传入 String 和 SubString 都可以。</p>
</blockquote>
<h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4><p>Swift 提供了三种比较文本值</p>
<ul>
<li>字符相等</li>
<li>前缀字符相等</li>
<li>后缀字符相等</li>
</ul>
<h4 id="字符串-字符相等"><a href="#字符串-字符相等" class="headerlink" title="字符串/字符相等"></a>字符串/字符相等</h4><p>可以使用 <code>==</code> 和 <code>!=</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let quotation = &quot;We&apos;re a lot alike, you and I.&quot;</span><br><span class="line">let sameQuotation = &quot;We&apos;re a lot alike, you and I.&quot;</span><br><span class="line">if quotation == sameQuotation &#123;</span><br><span class="line">    print(&quot;These two strings are considered equal&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印输出 &quot;These two strings are considered equal&quot;</span><br></pre></td></tr></table></figure>
<p>如果两个字符串（或者两个字符）的可扩展的字形群集是标准相等的，那就认为它们是相等的。在这个情况下，即使可扩展的字形群集是有不同的 Unicode 标量构成的，只要它们有同样的语言意义和外观，就认为它们标准相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// &quot;Voulez-vous un café?&quot; 使用 LATIN SMALL LETTER E WITH ACUTE</span><br><span class="line">let eAcuteQuestion = &quot;Voulez-vous un caf\u&#123;E9&#125;?&quot;</span><br><span class="line"></span><br><span class="line">// &quot;Voulez-vous un café?&quot; 使用 LATIN SMALL LETTER E and COMBINING ACUTE ACCENT</span><br><span class="line">let combinedEAcuteQuestion = &quot;Voulez-vous un caf\u&#123;65&#125;\u&#123;301&#125;?&quot;</span><br><span class="line"></span><br><span class="line">if eAcuteQuestion == combinedEAcuteQuestion &#123;</span><br><span class="line">    print(&quot;These two strings are considered equal&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印输出 &quot;These two strings are considered equal&quot;</span><br></pre></td></tr></table></figure>
<p>相反，英语中的 (U+0041，A)不等于俄语中的 (U+0410，A)。两个字符看着是一样的，但却有不同的语言意义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let latinCapitalLetterA: Character = &quot;\u&#123;41&#125;&quot;</span><br><span class="line"></span><br><span class="line">let cyrillicCapitalLetterA: Character = &quot;\u&#123;0410&#125;&quot;</span><br><span class="line"></span><br><span class="line">if latinCapitalLetterA != cyrillicCapitalLetterA &#123;</span><br><span class="line">    print(&quot;These two characters are not equivalent&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 打印 &quot;These two characters are not equivalent&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>Swift 中的字符和字符串不区分地域。</p>
</blockquote>
<h4 id="前缀-后缀相等"><a href="#前缀-后缀相等" class="headerlink" title="前缀/后缀相等"></a>前缀/后缀相等</h4><p>hasPrefix(<em>:) 和 hasSuffix(</em>:) 两个函数都接受 String 类型的参数， 返回一个布尔值。<br>下面用《罗密欧与朱丽叶》中前两场的场景位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let romeoAndJuliet = [</span><br><span class="line">    &quot;Act 1 Scene 1: Verona, A public place&quot;,</span><br><span class="line">    &quot;Act 1 Scene 2: Capulet&apos;s mansion&quot;,</span><br><span class="line">    &quot;Act 1 Scene 3: A room in Capulet&apos;s mansion&quot;,</span><br><span class="line">    &quot;Act 1 Scene 4: A street outside Capulet&apos;s mansion&quot;,</span><br><span class="line">    &quot;Act 1 Scene 5: The Great Hall in Capulet&apos;s mansion&quot;,</span><br><span class="line">    &quot;Act 2 Scene 1: Outside Capulet&apos;s mansion&quot;,</span><br><span class="line">    &quot;Act 2 Scene 2: Capulet&apos;s orchard&quot;,</span><br><span class="line">    &quot;Act 2 Scene 3: Outside Friar Lawrence&apos;s cell&quot;,</span><br><span class="line">    &quot;Act 2 Scene 4: A street in Verona&quot;,</span><br><span class="line">    &quot;Act 2 Scene 5: Capulet&apos;s mansion&quot;,</span><br><span class="line">    &quot;Act 2 Scene 6: Friar Lawrence&apos;s cell&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>使用 hasPrefix 计算第一幕的场景数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var act1SceneCount = 0</span><br><span class="line">for scene in romeoAndJuliet &#123;</span><br><span class="line">    if scene.hasPrefix(&quot;Act 1 &quot;) &#123;</span><br><span class="line">        act1SceneCount += 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;There are \(act1SceneCount) scenes in Act 1&quot;)</span><br><span class="line">// 打印输出 &quot;There are 5 scenes in Act 1&quot;</span><br></pre></td></tr></table></figure>
<p>使用 hasSuffix 来统计发生在不同地方的场景数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var mansionCount = 0</span><br><span class="line">var cellCount = 0</span><br><span class="line">for scene in romeoAndJuliet &#123;</span><br><span class="line">    if scene.hasSuffix(&quot;Capulet&apos;s mansion&quot;) &#123;</span><br><span class="line">        mansionCount += 1</span><br><span class="line">    &#125; else if scene.hasSuffix(&quot;Friar Lawrence&apos;s cell&quot;) &#123;</span><br><span class="line">        cellCount += 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;\(mansionCount) mansion scenes; \(cellCount) cell scenes&quot;)</span><br><span class="line">// 打印输出 &quot;6 mansion scenes; 2 cell scenes&quot;</span><br></pre></td></tr></table></figure>
<h4 id="字符串的-Unicode-表示形式"><a href="#字符串的-Unicode-表示形式" class="headerlink" title="字符串的 Unicode 表示形式"></a>字符串的 Unicode 表示形式</h4><p>一个 Unicode 字符串被写进文本或存储时，Unicode 标量会用 Unicode 中的几种编码格式（encoding forms）。每个字符串中的小块编码， 都被成为代码单元（code Units）。这些包括 UTF-8 编码格式（编码字符串为8位的代码单元）， UTF-16 编码格式（编码字符串位16位的代码单元），以及 UTF-32 编码格式（编码字符串32位的代码单元）。</p>
<p>Swift 提供了 3 种访问字符串的 Unicode 表示形式。</p>
<ul>
<li>UTF-8 代码单元集合（利用字符串的 utf8 属性进行访问）</li>
<li>UTF-16 代码单元集合（利用字符串的 utf16 属性进行访问）</li>
<li>21位的 Unicode 标量值集合，也就是字符串的 UTF-32 编码格式（利用字符串的 unicodeScalars 属性进行访问）</li>
</ul>
<h5 id="UTF-8-表示"><a href="#UTF-8-表示" class="headerlink" title="UTF-8 表示"></a>UTF-8 表示</h5><p>您可以通过遍历 String 的 utf8 属性来访问它的 UTF-8 表示。 其为 String.UTF8View 类型的属性，UTF8View 是无符号8位（UInt8）值的集合，每一个 UInt8 值都是一个字符的 UTF-8 表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for codeUnit in dogString.utf8 &#123;</span><br><span class="line">    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;&quot;)</span><br><span class="line">// 68 111 103 226 128 188 240 159 144 182</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/26/Swift-入门-第-4-课-字符串和字符/1.jpg" alt=""></p>
<p>上面的例子中，前三个10进制 codeUnit 值（68、111、103）代表了字符 D、o 和 g，它们的 UTF-8 表示与 ASCII 表示相同。 接下来的三个10进制 codeUnit 值（226、128、188）是 DOUBLE EXCLAMATION MARK 的3字节 UTF-8 表示。 最后的四个 codeUnit 值（240、159、144、182）是 DOG FACE 的4字节 UTF-8 表示。</p>
<h4 id="UTF-16-表示"><a href="#UTF-16-表示" class="headerlink" title="UTF-16 表示"></a>UTF-16 表示</h4><p>您可以通过遍历 String 的 utf16 属性来访问它的 UTF-16 表示。 其为 String.UTF16View 类型的属性，UTF16View 是无符号16位（UInt16）值的集合，每一个 UInt16 都是一个字符的 UTF-16 表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for codeUnit in dogString.utf16 &#123;</span><br><span class="line">    print(&quot;\(codeUnit) &quot;, terminator: &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;&quot;)</span><br><span class="line">// 68 111 103 8252 55357 56374</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/26/Swift-入门-第-4-课-字符串和字符/2.jpg" alt=""></p>
<p>同样，前三个 codeUnit 值（68、111、103）代表了字符 D、o 和 g，它们的 UTF-16 代码单元和 UTF-8 完全相同（因为这些 Unicode 标量表示 ASCII 字符）。</p>
<p>第四个 codeUnit 值（8252）是一个等于十六进制 203C 的的十进制值。这个代表了 DOUBLE EXCLAMATION MARK 字符的 Unicode 标量值 U+203C。这个字符在 UTF-16 中可以用一个代码单元表示。</p>
<p>第五和第六个 codeUnit 值（55357 和 56374）是 DOG FACE 字符的 UTF-16 表示。 第一个值为 U+D83D(十进制值为 55357)，第二个值为 U+DC36(十进制值为 56374)。</p>
<h4 id="Unicode-标量表示"><a href="#Unicode-标量表示" class="headerlink" title="Unicode 标量表示"></a>Unicode 标量表示</h4><p>您可以通过遍历 String 值的 unicodeScalars 属性来访问它的 Unicode 标量表示。 其为 UnicodeScalarView 类型的属性，UnicodeScalarView 是 UnicodeScalar 类型的值的集合。 UnicodeScalar 是21位的 Unicode 代码点。</p>
<p>每一个 UnicodeScalar 拥有一个 <strong>value</strong> 属性，可以返回对应的21位数值，用 UInt32 来表示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for scalar in dogString.unicodeScalars &#123;</span><br><span class="line">    print(&quot;\(scalar.value) &quot;, terminator: &quot;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;&quot;)</span><br><span class="line">// 68 111 103 8252 128054</span><br></pre></td></tr></table></figure>
<p><img src="/2018/12/26/Swift-入门-第-4-课-字符串和字符/3.jpg" alt=""></p>
<p>前三个 UnicodeScalar 值（68、111、103）的 value 属性仍然代表字符 D、o 和 g。</p>
<p>第四个 codeUnit 值（8252）仍然是一个等于十六进制 203C 的十进制值。这个代表了 DOUBLE EXCLAMATION MARK 字符的 Unicode 标量 U+203C。</p>
<p>第五个 UnicodeScalar 值的 value 属性，128054，是一个十六进制 1F436 的十进制表示。其等同于 DOG FACE 的 Unicode 标量 U+1F436。</p>
<p>作为查询它们的 value 属性的一种替代方法，每个 UnicodeScalar 值也可以用来构建一个新的 String 值，比如在字符串插值中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for scalar in dogString.unicodeScalars &#123;</span><br><span class="line">    print(&quot;\(scalar) &quot;)</span><br><span class="line">&#125;</span><br><span class="line">// D</span><br><span class="line">// o</span><br><span class="line">// g</span><br><span class="line">// ‼</span><br><span class="line">// 🐶</span><br></pre></td></tr></table></figure>
<p>【 参考 梁杰 极客学院 】</p>

  </section>

</article>

<section class="read-more">
           
    
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">Older Post</span>
                <h2 class="post-list__post-title post-title"><a href="/2018/12/25/Swift 入门 第 3 课 基本运算符/" title="Swift 入门 第 3 课 基本运算符">Swift 入门 第 3 课 基本运算符</a></h2>
                <p class="excerpt">
                
                运算符是检查、改变、合并值得特殊符号或短语。
Swift 支持 C 语言的基本运算符， 并做了改进， 避免错误。 例如： ”=“ 不返回值， 在编译时就可以检查出， 本来要使用 ”==“ ， 却使用了 ”=“ 的错误。算数运算符 +，-，*，/，% 等， 编译器会检测， 不允许值溢出。 这样可以避免
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2018-12-25T01:15:30.725Z" class="post-list__meta--date date">2018-12-25</time> &#8226; <span class="post-list__meta--tags tags">于 </span><a class="btn-border-small" href="/2018/12/25/Swift 入门 第 3 课 基本运算符/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

  

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 徐雪勇 - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78918255-1', 'auto');
	ga('send', 'pageview');
</script>

    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?9cdad07c755fa23f6aced510c6760e87";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
